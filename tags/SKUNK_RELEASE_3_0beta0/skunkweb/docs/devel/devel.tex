\documentclass{manual}
\usepackage{makeidx}
\usepackage[nottoc]{tocbibind} % make so bib and ind are in toc
\title{The SkunkWeb Developers Guide}
\author{Drew Csillag}
\release{3.0}
\setshortversion{3}
\makeindex

\begin{document}

%my commands here
\newcommand{\Location}{\texttt{Location}}
\newcommand{\PAR}{\texttt{par}}
\newcommand{\mskunkroot}[1]{\textit{SkunkRoot}\texttt{#1}}
\newcommand{\swpython}{\texttt{swpython}}
\newcommand{\connection}{\texttt{Connection}}
\newcommand{\NOTE}[1]{\textbf{\Large #1}}
\newcommand{\None}{\texttt{None}}
\newcommand{\nolocation}{[N]}


%function argument list environment
\newcommand{\argdescitem}[1]{\hspace\labelsep
                                \normalfont\ttfamily #1\ }
\newenvironment{argdesc}{\begin{list}{}{
        \renewcommand{\makelabel}{\argdescitem}
}
}{\end{list}}

%begin titlepage stuff
\maketitle
\ 
\vfill 
\noindent
This file documents the SkunkWeb Web Application Framework.

\noindent
Copyright (C) 2001 Andrew T. Csillag, Jacob Smullyan

\noindent
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

%%end titilepage stuff

\tableofcontents

\chapter{Introduction}
This is the intro


\chapter{Core Services}
The core services that SkunkWeb supplies are (intentionally) fairly minimal. 
The services provided are:
\begin{itemize}
\item The reading of configuration file(s)
\item The loading of Python modules or packages
\item A logging service
\item A multi-process TCP server framework
\item Two hooks, one for pre-\texttt{fork} initialization and one for
post-\texttt{fork} initialization.
\item An interactive Python prompt (a.k.a. \texttt{swpython})
\end{itemize}

\section{Configuration}
Configuration proceeds by first checking to see if a \verb!-c! or
\verb!--config-files=! option was specified (as a colon delimited list
of configuration files to read), if not, a configuration-time
hardcoded default is used.  A namespace is set up with a small amount
of preloaded stuff \footnote{The \texttt{Location} ``directive'' is loaded and the default \texttt{SkunkRoot} is set}
(and the configuration files executed (they're
Python programs really) in this namespace in the order given on the
command line (if given).


The configuration variables that the main bootloader understands are:

\begin{datadesc}{services}
 A Python list of services to load. \nolocation
\end{datadesc}
\begin{datadesc}{SkunkRoot}
 A directory to which many paths are relative to.
Defaults to the installation root. \nolocation
\end{datadesc}
\begin{datadesc}{numProcs} The number of child processes to maintain.  Defaults
to 15.  If set to 1, it will not detach from the controlling
terminal. \nolocation 
\end{datadesc}
\begin{datadesc}{maxKillTime} The number of seconds to wait for children to die
during a stop or restart before we kill them with \texttt{SIGKILL}.
Defaults to 5 seconds. \nolocation
\end{datadesc}
\begin{datadesc}{pidFile} The location of a file in which to put the process id
of the parent process. 
Defaults to the file \mskunkroot{/var/sw.pid}. \nolocation
\end{datadesc}
\begin{datadesc}{pollPeriod}  The frequency of which to check for dead children
and spawn new ones.  Defaults to 5. \nolocation
\end{datadesc}
\begin{datadesc}{maxRequests}
The maximum number of requests a child will handle before committing
suicide (and subsequently being reincarnated anew by the parent).
Defaults to 256.  Can be set to never recycle if \texttt{maxRequests}
is false (i.e. \None\ or 0, etc.). \nolocation
\end{datadesc}
\begin{datadesc}{userModuleCleanup}
Boolean specifying whether to unload any modules loaded during the
handling of a socket connection.  Default is false.
\end{datadesc}
\begin{datadesc}{accessLog} The location of where to put the component access
information.  Defaults to \mskunkroot{/logs/access.log}.  If set to
\None, no access log will be created. \nolocation
\end{datadesc}
\begin{datadesc}{errorLog} The location of where to put the error log
information.  Defaults to \mskunkroot{/logs/error.log}.  If set to
\None, no error log will be created. \nolocation
\end{datadesc}
\begin{datadesc}{regularLog} The location of where to log normal, but significant
events.  Defaults to \mskunkroot{/logs/sw.log}.  If set to
\None, no regular log will be created. \nolocation
\end{datadesc}
\begin{datadesc}{debugLog} The location of where to put debug information, if
any.  Defaults to \mskunkroot{/logs/debug.log}.  If set to
\None, no debug log will be created. \nolocation
\end{datadesc}
\begin{datadesc}{debugFlags} A bitmask of debug events that your are interested
in (see the shipped \texttt{sw.conf} file for specific flags).
Default is 0. 
\end{datadesc}


\label{location}
The \Location{} function loaded in the configuration file is used to
set configuration variables based on the location, where location is
loosely defined as the request URI in the case that SkunkWeb is being
used to server web requests, since the configuration overlaying is
actually done by the \texttt{web} service at present, but other
services may enable it also.

A typical use of the \Location{} function is as follows\footnote{This
example assumes use of the \texttt{basicauth} service}:
\begin{verbatim}
Location('/foob.html',
         basicAuthName='foo test',
         basicAuthFile='/home/drew/devel/skunk/SkunkWeb/'
                       'Services/basicauth/pwd'
         )
\end{verbatim}

This says: ``If the request URI starts with \verb!foob.html!, set
\texttt{basicAuthName} to \verb!'foo test'! and \texttt{basicAuthFile}
to \verb!/home/drew/devel/skunk/SkunkWeb/Services/basicauth/pwd!''.

The first argument to \Location{} is (assuming use of the \texttt{web}
service) a URI prefix for which it applies, and subsequent keyword
arguments are assignments to configuration variables that should take
place for the location in question. 

The \Location{} directive though, doesn't work for every configuration
variable.  Configuration variables that don't work with \Location{}
have the notation \nolocation next to them in their descriptions.


\subsection{The \texttt{SkunkWeb.Configuration} ``Module''}

The current configuration is available via the
\texttt{SkunkWeb.Configuration} ``module''.  In reality, it is not a
real Python module, but a class instance that has been set up to be
importable.  The implementation of the ``module'' is the
\texttt{Config} class in  \verb!pylibs/ConfigLoader.py!.

\begin{methoddesc}{\_mergeDefaults}{dict} Function taking a dictionary
argument. For each key/value in the dictionary, if current
configuration already has a variable with that name, it is skipped,
otherwise a the configuration variable named `key' is set to the
corresponding value. 
\end{methoddesc}
\begin{methoddesc}{\_mergeDefaultsKw}{**kwargs}  Same as
\texttt{\_mergeDefaults}, but uses keyword arguments instead of the
dictionary argument. 
\end{methoddesc}
\begin{methoddesc}{\_update}{dict} Updates the root configuration with the
contents of the argument (argument should be a dictionary-like
object). 
\end{methoddesc}
\begin{methoddesc}{\_push}{} Overlay configuration with the contents
of the argument (should be a dictionary-like object). 
\end{methoddesc}
\begin{methoddesc}{\_pop}{} Undo the last overlay.
\end{methoddesc}
\begin{methoddesc}{\_trim}{} Undo all overlays, resulting in just the
root configuration. 
\end{methoddesc}
\begin{methoddesc}{\_mash}{} No argument function that returns a
dictionary whose contents are the current view of the configuration.
\end{methoddesc}
\begin{methoddesc}{\_mashSelf}{} Sets the root configuration to
\verb![self._mash()]!. 
\end{methoddesc}

Since the configuration is read prior to the services being loaded,
the configuration is available to services at their time of import.

The configuration variables show up as attributes in the module
\verb!SkunkWeb.Configuration!.  Thus, the configuration
variable \texttt{debugFlags} would appear as
\verb!SkunkWeb.Configuration.debugFlags!.

\section{Service Loading}
The loading of services is done by the normal Python import facility.
This being the case, the directory(ies) that the service
modules/packages live in \strong{must} be in \texttt{sys.path}.  When
SkunkWeb is installed, the services shipped with SkunkWeb are placed
in a directory that is added to \texttt{sys.path} by the bootloader
automatically.  If you decide to move them, or add services of your
own (which should be located elsewhere so that future upgrades won't
accidentally wipe it out), you can add paths to \texttt{sys.path} in
the configuration file like so:
\begin{verbatim}
import sys
sys.path.append('/some/other/path')
\end{verbatim}

Even though a service sounds like a big deal, services are merely
Python modules and/or packages that are loaded 
just after the configuration has been read in.  Conventionally though,
service packages/modules assume presence of the SkunkWeb environment
(i.e. configuration information, hooks, etc.) and plug into the
SkunkWeb evironment in some way.


\section{Logging}
Logging is done by the \verb!SkunkWeb.LogObj! module.  The main
functions of interest are:

\begin{funcdesc}{DEBUG}{debugFlag, message} Takes two arguments, a debug flag (explained below) and a
message string.  If the flag masked against \verb!Configuration.debugFlags!
results in a non-zero value, the message is logged to the debug flag.
\end{funcdesc}
\begin{funcdesc}{DEBUGIT}{debugFlag} Take a single argument, a debug flag.  If the flag
masked against \verb!Configuration.debugFlags! 
results in a non-zero value, returns 1, else 0.  Useful for doing
computation for debug messages that you don't want to do if you aren't
going to log said message.
\end{funcdesc}
\begin{funcdesc}{LOG}{message} Takes one argument, the message to log.  Used for logging
normal, but significant events.
\end{funcdesc}
\begin{funcdesc}{WARN}{message} Takes one argument, the message to log.  Used for logging
events that require attention.  Logs to the error log file. 
\end{funcdesc}
\begin{funcdesc}{ERROR}{message} Takes one argument, the message to log.  Used for logging
erroneous events.  Logs to the error log file.
\end{funcdesc}
\begin{funcdesc}{ACCESS}{message} Takes one argument, the message to log.  Used mainly by
the \texttt{AE} library to log access events, but is available for
general use.  Logs to the access log.
\end{funcdesc}
\begin{funcdesc}{logException}{} Logs the current exception to the error log.
\end{funcdesc}


If, when SkunkWeb is started, standard out and/or standard error are
not TTY's (i.e. hooked to a terminal), they will be redirected to the
\texttt{LOG} nad \texttt{ERROR} functions, respectively.

\section{The \texttt{Server} Object}
The \texttt{Server} object handles the routing of TCP connections to
appropriate handlers, presumably installed during the loading of
Python modules, to handle whatever protocol is spoken over that TCP
connection. 

In the \texttt{SkunkWeb.Server} module there is a single function of
interest: 
\begin{funcdesc}{addService}{sockaddr, func}
Opens up a socket and listens for connections, and when connections
arrive calls \texttt{func} (with the \texttt{accept()}ed socket to
handle them. 
\begin{argdesc}
\item[sockaddr] An address specfier of one of two forms:
\begin{enumerate}
\item \texttt{('TCP', 'hostname', port)} --- bind to the TCP address
\texttt{host}/\texttt{port} where \texttt{port} is an integer.  To
bind to all addresses on host, specify the empty string as the
hostname.
\item \texttt{('UNIX', '/path/to/socket' [,
\textit{socket_permissions} ])} --- bind to the Unix socket located at
\verb!/path/to/socket! and optionally set the permissions of the
socket to \texttt{\textit{socket_permissions}}.
\end{enumerate}
\item[func] A function to call (with the socket) when a connection
comes in.
\end{argdesc}
\end{funcdesc}

\section{Hook Objects}
Hook objects are used in SkunkWeb to provide extensibility.  They
allow you to setup functions to be called at specific points in
processing.  They can be viewed as a list of functions to call 
(the \texttt{Hook} class is actually a subclass of \texttt{UserList})
that calls the functions in the list, in order, until one of them
returns a non-\None\ value.  The return value of calling a hook then,
is the return value of the function that returned a non-\None\ value,
or if all of the calls returned \None, the return value is \None.

\section{Initialization Hooks}

\begin{datadesc}{ServerStart}  Called after services have been imported but
before the server \texttt{fork()}s.
\end{datadesc}
\begin{datadesc}{ChildStart}
Called in the child process just after the \texttt{fork()}
\end{datadesc}


\section{\swpython}
\NOTE{NEEDS ATTENTION}
The \swpython{} program is just a symlink to the bootloader.  The
bootloader checks \texttt{sys.argv[0]} and if it happens to be
\swpython{}, instead of starting the multi-process server framework,
it starts an interactive Python interpreter session instead, or if a
filename argument was supplied to \swpython{}, it executes the file in
lieu of starting the interactive interpreter.  \NOTE{command line
switches}
\index{\swpython}

\section{\texttt{swmgr}}
\NOTE{NEEDS ATTENTION}

\chapter{The \texttt{web} Service}
\index{services!\texttt{web}}
The \texttt{web} service, is short provides base request phase
handling (extendable/configurable via hooks), an \connection\ object
and socket connectivity to 
Apache (via \texttt{mod\_skunkweb}).


\section{Configuration}

The configuration parameters are (all two of them):

\begin{datadesc}{DocumentTimeout} How long the request handling may 
take (with exception to the \texttt{RequestFailed} hook) before we
interrupt and kick back an error.  Defaults to 30. \nolocation
\end{datadesc}
\begin{datadesc}{WebListenPorts} 
a list of port specifications that the web service should listen to.
Defaults to \verb!['TCP:localhost:9888']!.  The port specifications
are defined as follows:
\begin{itemize}

\item To specify a TCP socket, the spec is:
\texttt{'TCP:\textit{hostname}:\textit{portnumber}} whereby if
\texttt{hostname} is empty, it will bind to all addresses available.
\item The spec:
\texttt{'UNIX:\textit{path}:\textit{octal\_permissions}'} specifies a
Unix domain socket whose location is \texttt{path} and whose file
permissions are \texttt{octal\_permissions}.
\end{itemize}
\nolocation
\end{datadesc}


\section{Protocol}
The protocol between the web listener (presumably Apache, but could be
something else) is as follows:
\begin{enumerate}
\item Client connects to server at some prearranged port
(\texttt{WebListenPorts}).
\item Server sends one byte (the byte value should be 0)
\item Client sends 10 byte ascii length of request (e.g. a length of
twenty would be sent as the ascii string \verb*!        20! (a 
\verb*! ! is a blank space)).
\item Client sends Python marshalled form of a dictionary whose
key/value pairs are:
\begin{description}
\item[\texttt{'stdin'}] the request body (in CGI-land, it's standard
input)
\item[\texttt{'headers'}] a dictionary of HTTP headers
\item[\texttt{'env'}] the CGI environment variables.
\end{description}
\item Server sends 10 byte ascii length of request --- as in (3).
\item Server sends full response (headers and body).
\item Both sides close connection.
\end{enumerate}

\section{Hooks Exposed}

\begin{datadesc}{InitRequest} Called with the raw request data as received from
Apache.  If the return value is a tuple of
(\textit{HTTP\_RESPONSE\_CODE}, string),  request processing stops and
the string (which is assumed to contain headers also) is sent back as
the response.
\end{datadesc}
\begin{datadesc}{HaveConnection} Called after the \connection\ object has been
constructed but before the location specific configuration has been
overlayed.
Argument is the \connection\ object.  If the
return value is an HTTP response code, the \connection\  object
is assumed to be complete and a response is sent.
\end{datadesc}
\begin{datadesc}{PreRequest} Called after the location specific configuration has been
overlayed.  Argument is the \connection\ object.  If the
return value is an HTTP response code, the \connection\  object
is assumed to be complete and a response is sent.
\end{datadesc}
\begin{datadesc}{HandleRequest} Called after the \texttt{PreRequest}
hook. Argument is the \connection\  object.  If the
return value is an HTTP response code, the \connection\  object
is assumed to be complete and a response is sent.  If no response code
is returned in the calling of this hook, a \texttt{'NoHandler'} string
exception is raised and processing proceeds to the
\texttt{RequestFailed} hook.
\end{datadesc}
\begin{datadesc}{PostRequest} Called after the response has been sent. Arguments
are the \connection\  object and the raw request data.  If the
exception occurs before the \connection\  has been constructed,
the connection argument is \texttt{None}, otherwise the raw request
data argument is \texttt{None}.
\end{datadesc}
\begin{datadesc}{CleanupRequest} Called after the \texttt{PostRequest} hook. Arguments
are the \connection\  object and the raw request data.  If the
exception occurs before the \connection\  has been constructed,
the connection argument is \texttt{None}, otherwise the raw request
data argument is \texttt{None}.
\end{datadesc}
\begin{datadesc}{RequestFailed} Called if there is an exception before a response
has been sent.  It should return the text of a full response
(i.e. headers and body).  After this hook returns (even if by a raised
exception), the \texttt{PostRequest} and \texttt{CleanupRequest}
handlers are called.
\end{datadesc}

\section{The \connection\  Object}
The \connection\ object is used to obtain information about the
request and to produce a response.  As such, it contains things like
the CGI arguments sent from forms, and things like the request and
response headers.  The attributes of the \connection\ object are as
follows:

\begin{memberdesc}[dictionary]{\_initRequestData}
 the raw data that the \connection\ object is
constructed from.  Is the same data that the \texttt{InitRequest} hook
is called with.
\end{memberdesc}
\begin{memberdesc}[integer]{\_status}
 The HTTP response code to send back to Apache.  If not
otherwise set via call to \texttt{setStatus()}, is 200.
\end{memberdesc}
\begin{memberdesc}[dictionary]{env}
 The CGI environment set by Apache.
\end{memberdesc}
\begin{memberdesc}[string]{\_stdin}
The request body text sent by the browser to Apache.
\end{memberdesc}
\begin{memberdesc}[HeaderDict]{requestHeaders} The HTTP headers of the request.
\end{memberdesc}
\begin{memberdesc}[Cookie]{requestCookie} The cookie sent by the browser.
\end{memberdesc}
\begin{memberdesc}[HeaderDict]{responseHeaders} The HTTP headers to be
sent in the response. 
\end{memberdesc}
\begin{memberdesc}[Cookie]{responseCookie} The cookie to be sent in
the response.
\end{memberdesc}
\begin{memberdesc}[File]{\_output} A file-like object that contains
the body of the response. 
\end{memberdesc}
\begin{memberdesc}[Browser]{browser} An object with three attributes
that describes the user agent as sent in the \texttt{User-Agent} HTTP header.  Those attributes are:

\begin{memberdesc}[string]{version} the version of the client browser
\end{memberdesc}
\begin{memberdesc}[string]{lang} the language of the client browser
\end{memberdesc}
\begin{memberdesc}[string]{name} the name of the client browse (e.g. Mozilla)
\end{memberdesc}
\end{memberdesc}
\begin{memberdesc}[dictionary]{args} A dictionary of CGI variables.
\end{memberdesc}
\begin{memberdesc}[string]{uri} The URI of the request.
\end{memberdesc}

\begin{methoddesc}{redirect}{url}  A function taking a URL that sets the appropriate response
variables to enact a redirect.  
\end{methoddesc}
\begin{methoddesc}{setContentType}{contentType}  Convienience function taking a single argument
to set the \texttt{Content-Type} header.  Equivalent to:
\begin{verbatim}
connObj.responseHeaders['Content-Type'] = arg
\end{verbatim}
\end{methoddesc}
\begin{methoddesc}{write}{s} Function taking a string to be written into the request body.
\end{methoddesc}
\begin{methoddesc}{setStatus}{statusCode} Set the HTTP response code to the integer argument.
\end{methoddesc}
\begin{methoddesc}{response}{} Returns a string containing the full text of the response.
\end{methoddesc}


\chapter{The \texttt{templating} Service}
\index{services!\texttt{templating}}
The main raison d'\^etre of the \texttt{templating} service is to
integrate the \texttt{AE} library (see Appendix \ref{aelib}, page
\pageref{aelib}).  The \texttt{AE} library, in short, is responsible
for the component rendering, caching and message catalog facilities
that are generally the reason for using SkunkWeb in the first place.

\section{Configuration}

\begin{datadesc}{indexDocuments} If the URI is a directory, which files (in
order) to look for to show.  Defaults to \verb!['index.html']!.
\end{datadesc}
\begin{datadesc}{documentRoot} Location of web document sources.  The default
location is \mskunkroot{/docroot}.
\end{datadesc}
\begin{datadesc}{compileCacheRoot}  Where to store cached compiled
objects.  The default location is \mskunkroot{/cache}.
\end{datadesc}
\begin{datadesc}{componentCacheRoot}  Where to store the cached output of
components.  Defaults to \mskunkroot{/cache}.
\end{datadesc}
\begin{datadesc}{numServers} If splitting the component cache across
multiple file servers, the number of servers you are using, see Section
\ref{ccdist}, page \pageref{ccdist} for details.   Default is 0.
\end{datadesc}
\begin{datadesc}{failoverComponentCacheRoot} If \texttt{numServers} is greater
than 0, the location of a local disk area to be used for component
cache if one of the file servers fails.  Default is
\mskunkroot{/failoverCache}.
\end{datadesc}
\begin{datadesc}{maxDeferStale} The maximum amount of time, past a cached
components expiration that the output will still be used if called in
deferred mode, specified in seconds.  Default is 3600 seconds.
\end{datadesc}
\begin{datadesc}{deferAdvance} How many seconds to temporarily extend
the life of an expired component when deferred execution will take
place specified in seconds.  Default is 30.
\end{datadesc}
\begin{datadesc}{failoverRetry} How long should we use the failover cache after
a compile cache failure before checking the main compile cache again,
specified in seconds.  Default is 30.
\end{datadesc}
\begin{datadesc}{useCompileMemoryCache} Boolean specifying whether or not to
cache compiled objects in memory.  Default is 0.
\end{datadesc}
\begin{datadesc}{findCommand} Path to GNU find.  Default is
\verb!/usr/bin/find!. 
\end{datadesc}
\begin{datadesc}{sedCommand} Path to \texttt{sed}.  Default is \verb!/bin/sed!.
\end{datadesc}
\begin{datadesc}{xargsCommand} Path to \texttt{xargs}.  Default is
\verb!/usr/bin/xargs!. 
\end{datadesc}
\begin{datadesc}{fgrepCommand} Path to \texttt{fgrep}.  Defalut is \verb!/bin/fgrep!.
\end{datadesc}
\begin{datadesc}{defaultDefer} Boolean specifying whether all cached component
calls are deferred by default.  Default is 0.
\end{datadesc}
\begin{datadesc}{defaultExpiryDuration} If a cached component didn't specify a
cache lifetime, the duration of the components validity specified in
seconds.  Default is 30.
\end{datadesc}
\begin{datadesc}{fallbackToCache} If rendering of a cached component raises
an exception, if true, will use the previously cached version if
available.  Default is \None.
\end{datadesc}
\begin{datadesc}{strictMessageCatalogs} When set to false, fetching a
non-existant message from the message catalog won't raise an
exception, but will return a message saying ``no such message''.
Default is 1.
\end{datadesc}
\begin{datadesc}{templateMimeTypes} A Python list of mime types that the
component engine will treat as templates.  Default is
\texttt{['text/html', 'text/plain']} 
\end{datadesc}
\begin{datadesc}{mimeTypesFile} File that holds the file extension to mime type
mapping.  Default is \mskunkroot{/etc/mime.types}.
\end{datadesc}
\begin{datadesc}{defaultMimeType} The mime type to return in the event that the
mime type can not be determined.  Default is
\texttt{application/octet-stream}. 
\end{datadesc}
\begin{datadesc}{hideMimeTypes} List of mime types of documents (based on file
extension) that shouldn't be web accessible.  Default is:
\begin{verbatim}
[
    "text/x-stml-component",
    "text/x-stml-python-component",
    "text/x-stml-data-component",
    "text/x-stml-python-data-component",
]
\end{verbatim}[N]
\end{datadesc}
\begin{datadesc}{interpretMimeTypes}
A list of mime types that will be interpreted if accessed via the web.
If not interpreted, will be sent in raw form.  Default is:
\begin{verbatim}
[
    "text/html",
    "application/x-python"
]
\end{verbatim}[N]
\end{datadesc}


\section{API}
The API to the \texttt{templating} service is actually quite minimal,
as most of the interesting bits are in the \texttt{AE} library proper.

\subsection{\texttt{templating.MailServices.sendmail}}

In the \texttt{templating.MailServices} module, there is one function
of interest:

\begin{funcdesc}{sendmail}{to_addrs, subj, msg, from_addr =
Configuration.FromAddress} 
The general-purpose sendmail function, which is called
    by the STML \texttt{<:sendmail:>} tag, or directly by Python code.

\begin{argdesc}
\item[to\_addrs] should be a list or tuple of email address
    strings. 
\item[subj] must be a string, although it may be empty.
\item[msg] is a string containing the body of the message; it can
    be empty. 
\item[from\_addr] is a single mail address string; it 
    defaults to the value of the \texttt{FromAddress} configuration variable.
\end{argdesc}
This function returns nothing on success, and raises a
\texttt{MailError} on any mail failure. 

\end{funcdesc}





\subsection{\texttt{templating.UrlBuilder} Functions}

\begin{funcdesc}{url}{path, queryargs, text = None, kwargs = {},
noescape = None, url = None}

Returns either the url part of the request (\texttt{http://path}) or
(if \texttt{text} is not \None) the complete link:
\verb!<A href="http://path">text</A>!. 

If the \texttt{url} argument is given, it is used in place of
\texttt{path} and \texttt{query}.

\begin{argdesc}
\item[path] Path to the target document.
\item[queryargs] Any HTTP GET style CGI arguments.
\item[text] Text to appear between the open and close \texttt{<A>} tags.
\item[kwargs] Any additional arguments to the open \texttt{<A>} tag
(e.g. \texttt{onClick}).
\item[noescape] Boolean specifying that the path should not be
properly escaped.
\item[url] As an alternate to \texttt{path}, the full absolute URL to the
target document.
\end{argdesc}
\end{funcdesc}


\begin{funcdesc}{image}{path, queryargs = None, kwargs={}, noescape = None}

Generate an HTML \texttt{<IMG>} tag.  Arguments are the same as those
for \texttt{url}.
\end{funcdesc}


\begin{funcdesc}{form}{path, kwargs = {}, noescape = None}
Generate an HTML \texttt{<FORM>} tag.  Arguments are the same as those
for \texttt{url}.
\end{funcdesc}


\begin{funcdesc}{redirect}{path = None, url = None, queryargs = {},
kwargs = {}, noescape = None} 
Cause a redirect to either the URL specified or to the path specified.
Arguments are the same as those for \texttt{url}.  
\end{funcdesc}

\begin{funcdesc}{retain}{dict}
Returns a string containing HTML \texttt{<INPUT TYPE=HIDDEN>} tags
that contain the contents of \texttt{dict}.  The dictionary keys are
used for the \texttt{NAME} arguments and the corresponding values are
used for the \texttt{VALUE} arguments.
\end{funcdesc}


\section{Component Cache Distribution}
\NOTE{NEEDS ATTENTION}
\label{ccdist}

\chapter{The \texttt{pars} Service}
\index{services!\texttt{pars}}
The \texttt{pars} service is present to allow you to maintain the
docroot \'al\`a java-style/\texttt{CLASSPATH}, sorta.  It allows you
to store items that would normally be required to be in the docroot,
in special archive files called par files.  So instead of just looking
in the docroot for docroot items, it first looks in the par files
specified in th \texttt{parFiles} configuration variable and only
then, if \texttt{parFallthrough} is specified, look in the docroot.

\section{Configuration}
\begin{datadesc}{parFiles} An ordered list of parfiles to search for items
normally found in the \texttt{documentRoot}.  Defaults to the empty
list. \nolocation
\end{datadesc}
\begin{datadesc}{parFallthrough} Whether or not to actually fall through to the
\texttt{documentRoot} if the parfile search fails.
\end{datadesc}

\section{The \texttt{par.py} Archive Tool}
The \texttt{par.py} program is used to create and extract files from
\PAR\ files.  It has three modes of operation: create, list and
extract.

To create \PAR\ files, type:
\begin{verbatim}
python par.py c parfile_to_create.par file_or_dir1 file_or_dir2 ...
\end{verbatim}

To list the contents of \PAR\ files, type:
\begin{verbatim}
python par.py t parfile_to_list.par
\end{verbatim}

To extract tho contents of \PAR\ files, you can either extract
everything or extract only certain files.  To extract everything,
type:
\begin{verbatim}
python par.py x parfile_to_extract.par
\end{verbatim}

Otherwise,
\begin{verbatim}
python par.py x parfile_to_extract.par file_or_dir1 file_or_dir2 ...
\end{verbatim}


\section{The \PAR\ File Format}
The \PAR\ file format is quite simple.  What it is is a Python
marshalled format dictionary where the keys are directory/file names
and the values are a tuple of the offset into the data area (I'll get
to that in a second) and the information acquired at packaging time
from calling \texttt{os.stat()} on the file.

After the marshalled dictionary is the data area.  The data area is
where the contents of the files are stored (directiories, obviously
don't have anything here).  So, if you've loaded the dictionary into a
variable named, say \texttt{archDict}, and the data area loaded into
\texttt{dataArea} you can obtain the contents by:
\begin{verbatim}
offset, stat_info = archDict[filename]
contents = dataArea[offset:offset + stat_info[stat.ST_SIZE]]
\end{verbatim}


\chapter{The \texttt{oracle} Service}
\index{services!\texttt{oracle}}
The \texttt{oracle} service exists to 
speed up stored procedure calls (by prefetching their signatures) and
to cache database connections by preloading and providing an interface
to the \texttt{SQL} module.

\section{Configuration}

\begin{datadesc}{OracleConnectStrings} A dictionary of connection
alias to oracle connection strings. \nolocation
\end{datadesc}
\begin{datadesc}{OracleProcedurePackageLists} A dictionary of connection alias to
stored procedure package names to preload on server start. \nolocation
\end{datadesc}


\section{API}
Provides interface to \texttt{SQL} module.  Consult
the pylibs manual for details.




\chapter{The \texttt{basicauth} Service}
\index{services!\texttt{basicauth}}

The \texttt{basicauth} service provides a basic authentication
mechanism for browser based authentication.

\section{Configuration}

The \Location{} ``directive'' mentioned in Section \ref{location},
page \pageref{location} is often used in conjunction with the
\texttt{basicauth} service to provide access control to some subset of
the docroot.

\begin{datadesc}{basicAuthName} The ``realm'' to use in the
\verb!WWW-Authenticate! header when accessing a protected area.
\end{datadesc}
\begin{datadesc}{basicAuthFile} The file to use for determining valid
user/password combinations.
\end{datadesc}


\section{API}
The \texttt{basicauth} service adds a few things to the
\connection\ object.  Namely,
\begin{memberdesc}[string]{AUTH_TYPE} The type of authentication,
should always be \verb!'Basic'!.
\end{memberdesc}
\begin{memberdesc}[string]{REMOTE_USER} The name that the browser
specified when authenticating to the server.  May be \None.
\end{memberdesc}
\begin{memberdesc}[string]{REMOTE_PASSWORD} The password that the browser
specified when authenticating to the server.  May be \None.
\end{memberdesc}

\section{The \texttt{swpasswd} Utility}
The \texttt{swpasswd} utility is a simple program to maintain
password files.  

Its general form is:
\begin{verbatim}
swpasswd [-cb] password_file username [password]
\end{verbatim}

The two options are:
\begin{argdesc}
\item[-c] Create a new password file
\item[-b] Specify the password on the command line as opposed to being
asked for it interactively.
\end{argdesc}



\chapter{The \texttt{vhost} Service}
\index{services!\texttt{vhost}}

The \texttt{vhost} service allows you to service more than one
host/port combination from one running SkunkWeb server.  You don't
need to use the \texttt{vhost} service if all of the host/port combos
that point to a runnig SkunkWeb server are supposed to show the same
content, it is only when they are supposed to show host/port specific
content.

The way this is achieved is by prepending the host (and if other than
the default, port) to the uri.  Thus if you want to have specific
content for a host/port combo \verb!foo.bar.com:8080!, the first part
of the uri (and as such, path in the docroot) would be
\verb!foo.bar.com:8080!.  If you are unsure of what the uri gets
prefixed with, you can turn on the \texttt{VHOST} debugging flag and
look in the debug log.

This way if you have \Location\ directives in the configuration file,
you just prepend the requisite host/port thing to the path name.  For
example:
\begin{verbatim}
   Location('technet-dev.starmedia.com/', parFallthrough = 1)
\end{verbatim}
This would tell the \texttt{pars} personality (presuming you are using
it, that is) that for all accesses, if the host is
\verb!technet-dev.starmedia.com!, the \texttt{parFallthrough} feature
will be on.

That's it.  Really.


\chapter{Writing A Service}

uri rewriting likely in web.HaveConnection

cookie auth schemes (probably also in web.HaveConnection)

document handlers

daisy chaining functions \'al\`a basicauth


an example easter egg service

a remote swpython example?  if so, warn why \textbf{really} bad

\textbf{Explain the \texttt{SkunkWeb.Configuration} ``module'' and
it's methods and that the namespace above is in this object}

\verb!_mergeDefaultsKw!

Hooks

The \verb!Server! interface

A request recording service


\appendix
\input ae.tex


\cleardoublepage

\printindex

\end{document}
