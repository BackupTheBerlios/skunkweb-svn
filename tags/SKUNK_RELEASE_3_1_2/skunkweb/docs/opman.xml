<title>Skunk Software Operations Manual</title>
<author>By Drew Csillag</author>

<chapter id="intro">
<title>Introduction</title>

<p/>This manual explains the installation and use of the software
included in the Skunk software distribution.

<p/>The Skunk software distribution has one main software tool: 
the AED web application server. AED stands for Application Environment
Daemon, and AED's purpose is to provide a programming environment that
makes it easy to build applications that generate "dynamic documents"
in response to Web (HTTP) requests. Think of AED as doing the same job as
Vignette StoryServer, ASP, ColdFusion, or regular CGI applications.

<p/>The other software tools are utilities to help you use AED, or
general-purpose software to help in web applications programming. This manual
will concentrate almost exclusively on the use of AED, with little or no mention
of the other software in the distribution.

</chapter>

<chapter id="installation">
<title>Installation</title>

<section id="prereqs">
<title>Prerequisites</title>

<subsection id="hardwarereqs">
<title>Hardware and Operating System Prerequisites</title>

<p/>The Skunk AED server, and all of the other software in 
the Skunk distribution, are designed to run on any Unix
system. We have successfully built and installed Skunk software
on Solaris 2.6 and 2.7, various flavors of Linux 2.x, and
recent versions of FreeBSD.

<p/>There are no other hardware or operating system requirements.

</subsection>

<subsection id="softwarereqs">
<title>Software Prerequisites</title>
<p/>The following software packages must be installed prior to installing the Skunk software.

<ul>
<li><a href="ftp://ftp.gnu.org/pub/gnu/make/make-3.79.tar.gz">GNU Make</a>
</li><li><a href="ftp://ftp.gnu.org/pub/gnu/bash/bash-2.04.tar.gz">GNU BASH</a>
</li><li><a href="ftp://ftp.gnu.org/pub/gnu/gawk/gawk-3.06.tar.gz">GNU Awk</a>
</li><li><a href="ftp://ftp.gnu.org/pub/gnu/gcc/gcc-2.95.2.tar.gz">gcc-2.95.2</a> (earlier versions are very likely ok)
</li><li><a href="ftp://ftp.gnu.org/pub/gnu/findutils-4.1.tar.gz">GNU findutils-4.1</a>
</li><li><a href="ftp://ftp.gnu.org/pub/gnu/fileutils-4.0.tar.gz">GNU fileutils-4.0</a>
</li><li><a
href="http://www.apache.org/dist/apache_1.3.12.tar.gz">apache_1.3.12</a>
configured with (at least) the switch <tt>--enable-module=so --disable-module=dir --disable-module=autoindex</tt>.  Skunk will
<b>not</b> build unless Apache has been configured for dynamic 
extension modules and will operate in occasionally very strange ways
if the <tt>autoindex</tt> or <tt>dir</tt> modules are enabled. 
</li><li><a HREF="http://www.courtesan.com/sudo/dist/sudo-1.6.3p5.tar.gz">Sudo</a>
</li><li><a
HREF="http://www.python.org/ftp/python/src/py152.tgz">Python 1.5.2</a>
compiled with the <tt>crypt</tt> and <tt>syslog</tt> modules
installed. Much of the Skunk software is written in Python 1.5.2;
the exact version of Python is very important.
</li><li><b>Oracle client, precompiler, and some Oracle server files.</b> The Skunk software
includes a Python interface to Oracle called <tt>DCOracle</tt>. Since most of
our web applications use Oracle databases, the DCOracle install is required.
DCOracle, for some reason, requires not just the Oracle client libraries, but also
the Oracle precompiler and some obscure files that can only be found in a full
Oracle server installation. It is recommended that your machine have a full Oracle
server installation to make DCOracle installation smooth and easy. If this is not
possible, consult with Skunk software engineers to construct a custom Oracle
installation that will support DCOracle.
<p/>DCOracle is well-tested with Oracle 8.0.5 and 8.0.6 on Solaris and Linux. DCOracle
has also been successfully built and used with Oracle 8.1.x on Linux.
</li>
<li><a href="http://www.python.org/sigs/xml-sig/files/">PyXML</a>, specifically for the helix persona (PyXML version 0.5.5.1 is known to work).</li> 
</ul>

</subsection>
<subsection id="userreqs">

<title>User and Group Prerequisites</title>

It is recommended that the AED server run as the same user that the
Apache server runs as. Historically, we have created a user named
<tt>apache</tt>, with a home group named <tt>http</tt>, for both
Apache and AED to run under. The Skunk software installation will create
many directories and files owned by the user/group you choose during
the installation; we recommend that you create the user <tt>apache</tt>
and group <tt>http</tt> before starting the Skunk installation,
so that the Skunk installer can use <tt>apache:http</tt> to set
ownership of the files it installs.

</subsection>

</section>

<section id="fetchingsource">
<title>Fetching the Source Code</title>
The source code is available from <a 
href="http://support.skunk.org/download/?p=skunk/AED">
<tt>support.skunk.org</tt></a>.  The links to the releases are at the bottom 
of the page.  Skunk releases are named 
<tt>skunk-x.xx.tgz</tt> and are a gzipped tarball, where x.xx is the version number of the release.  
If you need the username and password 
to access the support website, contact either Drew Csillag or Robin Thomas.
</section>

<section id="unpacking">
<title>Unpacking the Tarball</title>
To unpack the tarball under the current directory (a directory named 
<tt>skunk-2.xx</tt> will be created):
<pre>
gzip -dc skunk-2.xx.tgz | tar xvf -
</pre>
</section>

<section id="buildconfiguration">
<title>Configuration and Build</title>
First, log in as root.  Then make sure that directory that you
installed the GNU 
packages and Python into (via their --prefix argument, otherwise it's 
<tt>/usr/local</tt>) is in your <tt>PATH</tt> <b>before</b>
<tt>/usr/ccs/bin</tt> (in fact, it's probably best if it were just
first in your <tt>PATH</tt>).  
The <tt>bin</tt> directory of the apache install must also be in your
path for configuration to succeed.
If you did the default
installs, you would add <tt>/usr/local/bin</tt> and
<tt>/usr/local/apache/bin</tt> like this (for a
bourne-like shell (bash, ksh, sh, etc.)):
<pre>
# PATH=/usr/local/bin:$PATH:/usr/local/apache/bin
# export PATH
</pre>

Also, we need to make sure that the <tt>ORACLE_HOME</tt> environment
variable points to the Oracle installation.  

You should get something like this:
<pre>
# ls $ORACLE_HOME/bin/sqlplus
/opt/oracle/product/8.0.6/bin/sqlplus
</pre>

If you get something like this:
<pre>
ls: /bin/sqlplus: No such file or directory
</pre>
Get your <tt>ORACLE_HOME</tt> environment variable set to the correct
value before continuing.  If in doubt, ask the local Oracle guru.

Depending on how GNU Make was installed, there should be an executable
named <tt>gmake</tt> in your path.  If not, there needs to be.Assuming
that GNU Make was 
installed in <tt>/usr/local/</tt>, make a link named <tt>gmake</tt> to
<tt>make</tt> by doing the following:
<pre>
# ln -s /usr/local/bin/make /usr/local/bin/gmake
</pre>

Now we need to <tt>cd</tt> to the <tt>skunk-2.xx</tt> directory
created when we unpacked the tarball, and run the <tt>setup.py</tt>
script like this:

<codeblock>
# cd skunk-2.70
# python ./setup.py
</codeblock>
The setup script is now going to ask you a few questions.

<codeblock>
Welcome to Skunk software installation
First we'll check a few things
checking for syslog module... Ok
checking for crypt module... Ok
Second, we need to ask a few questions
Do you wish to install AED? [Y/n]
</codeblock>
If it fails checking for either the <tt>syslog</tt> or <tt>crypt</tt> modules,
see <xref id="extramods"/> on how to correct this.
Since we do want to install AED, just press enter.

<pre>
Do you wish to install DCOracle library - 
NOTE: full Oracle 8 server installation required to build? [y/N]
</pre>
We do want to install the DCOracle library since it enables AED to
talk to Oracle so type <tt>Y</tt> and press enter.

<pre>
Enter default prefix for the installation? [/usr/local/skunk]
</pre>
If <tt>/usr/local/skunk</tt> is where you want to install it (more
than likely, the answer here is "yes"), press enter, otherwise type
the path to which skunk will be installed into.

<pre>
Enter the username to install as? [drew]
</pre>
This probably should be changed as it should probably be
<tt>apache</tt>.  So type <tt>apache</tt> and press enter.

<pre>
Enter the group to install as? [drew]
</pre>
This probably should be changed as it should probably be
<tt>http</tt>.  So type <tt>http</tt> and press enter.

You may potentially get a message like the following:
<pre>
WARNING: directory /usr/local/skunk/webroot exists. The installation usually 
installs some sample documents there. If you did any 
development in that directory, files could be lost.
If you would like to skip the the AED documents 
installation, answer "y" (default) to the next question
Skip default content installation? [Y/n]
</pre>

Pressing enter here is more than likely what you want to do.

<pre>
Please choose which personalities to install.
The templating personality is installed by default. You can
install a number of additional personalities, depending on what
you are planning to do with the server

Do you wish to install personality mysql? [y/N]
</pre>
Since we don't use MySQL in production, just press enter (for no).

<pre>
Do you wish to install personality helix? [y/N]
</pre>
Since StarMedia applications use either the <code>helix</code> or the
<code>superteam</code> personalities, say yes.

<pre>
Do you wish to install personality postgresql? [y/N]
</pre>
Likewise for PostgreSQL, just press enter (for no).

<pre>
Do you wish to install personality superteam? [y/N]
</pre>
This we do want to say yes to since it's used by StarMedia skunk-based
applications.  So press <tt>Y</tt> and hit enter.

<pre>
Do you wish to install personality sql? [y/N]
</pre>
This is the personality which, in part, enables AED to access Oracle,
so press <tt>Y</tt> and hit enter.

<pre>
Do you wish to install personality skunkorg? [y/N]
</pre>
This is the personality used by the <tt>support.skunk.org</tt>
website, so you don't need it, so just press enter (for no).

You should then see something resembling the following:
<pre>
This is what you have selected:
Installation directory: /usr/local/skunk
User to install as: apache.http
Install AED
--> Selected personalities: templating, superteam, sql
--> Install sample Web content
Install DCOracle oracle python interface

Are you sure you want to proceed? [Y/n]
</pre>
If everything looks ok, press enter to continue.

You will then see a bunch of output that start with:
<pre>
Running selected configure scripts...
===== Running top level config
loading cache ./config.cache
checking for gcc... (cached) gcc
checking whether the C compiler (gcc  ) works... yes
checking whether the C compiler (gcc 
</pre>

If everything went ok, the last bits you should see on your screen are these:
<pre>
creating AECore/aed.py
creating util/aedmgr
creating util/viewmeta.py
creating util/cache_reaper.py

All done! Now run gmake; gmake install to install Skunk
</pre>

If you see the following error, the configure script could not locate
<tt>apxs</tt>, the apache extension building utility.
<pre>
checking for apxs... notfound
configure: error: apxs not found! Make sure Apache is installed
AED config failed
</pre>
In this case check your <tt>PATH</tt> environment to see that it
contains a directory which contains the <tt>apxs</tt> binary.  

There is a similar error which would occur if you did not configure
Apache for dynamic module (sometimes referred to as DSO) support.  If
that is what the error said, reconfigure and rebuild apache with (at
least) the switch <tt>--enable-module=so</tt> and retry configuring AED.

If you see the following error:
<pre>
checking for gmake... no
./configure: test: argument expected
Top level config failed
</pre>
This means that the <tt>gmake</tt> program could not be found.
Likely, it is because you didn't do the check mentioned previously.
Go back and make the symlink and try again.

Now:
<pre>
# gmake
</pre>


You should then see lines like this spew out:
<pre>
Building component pylibs...
make[1]: Entering directory `/home/drew/build/skunk-2.70/pylibs'
(dirname=`echo signal_plus/Makefile.pre.in | sed 's@/Makefile.pre.in$@@'`; \
         make -C $dirname -f Makefile.pre.in boot)
make[2]: Entering directory `/home/drew/build/skunk-2.70/pylibs/signal_plus
'
rm -f *.o *~
rm -f *.a tags TAGS config.c Makefile.pre python sedscript
rm -f *.so *.sl so_locations
VERSION=`python -c "import sys; print sys.version[:3]"`; \
installdir=`python -c "import sys; print sys.prefix"`; \
exec_installdir=`python -c "import sys; print sys.exec_prefix"`; \
make -f ./Makefile.pre.in VPATH=. srcdir=. \
        VERSION=$VERSION \
</pre>

<h2>Expected Warnings And Other Compiler/Linker Messages</h2>

A whole bunch of these:
<pre>
./mxDateTime.c: In function `mxDateTime_Getattr':
./mxDateTime.c:1876: warning: offset outside bounds of constant string
</pre>

Some others to be expected:
<pre>
In file included from ./oci_.c:562:
Buffer.h:79: warning: static declaration for `PyImport_Import' follows 
non-static
In file included from ./oci_.c:693:
oci_8.c: In function `Logon':
oci_8.c:154: warning: passing arg 4 of `OCIHandleAlloc' makes integer from 
pointer without a cast
oci_8.c:189: warning: passing arg 1 of `OCIServerAttach' from incompatible
pointer type
oci_8.c: In function `newLob':
oci_8.c:561: warning: passing arg 4 of `OCIDescriptorAlloc' makes integer 
from pointer without a cast
oci_8.c: In function `initoci_8':
oci_8.c:598: warning: passing arg 3 of `OCIEnvInit' makes integer from 
pointer without a cast
./oci_.c: In function `_wrap_ogetpi':
./oci_.c:2879: warning: assignment from incompatible pointer type
./oci_.c:2882: warning: assignment from incompatible pointer type
gcc: -lclntsh: linker input file unused since linking not done
gcc: -lcore4: linker input file unused since linking not done
gcc: -lcommon: linker input file unused since linking not done
gcc: -lcore4: linker input file unused since linking not done
gcc: -lnlsrtl3: linker input file unused since linking not done
</pre>

<pre>
In file included from ./Buffer.c:60:
Buffer.h:79: warning: static declaration for `PyImport_Import' 
follows non-static
</pre>

Anything other than these may be (probably isn't) a problem, so check
with Drew Csillag.  Of course, if you don't see these, that's ok too.

Now it's time to install:
<pre>
# gmake install
</pre>
If all goes well you should see something similar to the following:
<pre>
Installing component pylibs...
gmake[1]: Entering directory `/home/drew/build/skunk-2.70/pylibs'
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
for f in Buffer.so oci_.so; do \
    /usr/bin/install -c -o apache -g http -m 644 -o apache -g http -D 
./src/${f} /usr/local/skunk/pylibs/DCOracle/DCOracle/${f}; \
        done
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
for f in Buffer.so oci_.so; do \
    /usr/bin/install -c -o apache -g http -m 644 -o apache -g http -D 
./src/${f} /usr/local/skunk/pylibs/DCOracle/DCOracle/${f}; \
        done
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
gmake[1]: Leaving directory `/home/drew/build/skunk-2.70/pylibs'
Installing component AED...
gmake[1]: Entering directory `/home/drew/build/skunk-2.70/AED'
Creating AED directory tree...
Installing component mod_aecgi...
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/AED/mod_aecgi'
/usr/local/apache/bin//apxs -i mod_aecgi.so
cp mod_aecgi.so /home/drew/programs/apache/libexec/mod_aecgi.so
chmod 755 /home/drew/programs/apache/libexec/mod_aecgi.so
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/AED/mod_aecgi'
Installing component personalities...
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/AED/personalities'
Installing personality templating...
Installing personality superteam...
Installing personality sql...
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/AED/personalities'
Installing web content
gmake[1]: Leaving directory `/home/drew/build/skunk-2.70/AED'
# 
</pre>

The following error has been seen when building on Linux machines:
<pre>
make[2]: Entering directory
`/usr/local/downloads/skunk-2.73.beta4/AED/mod_aecgi'
   /usr/local/apache/bin/apxs -c -Wc,"-g -O2 -Wall -D_GNU_SOURCE 
   -DHAVE_MEMMEM=1 -DSTDC_HEADERS=1 -DHAVE_LIMITS_H=1 -DHAVE_UNISTD_H=1 " 
   -o mod_aecgi.so mod_aecgi.c
gcc -DLINUX=2 -DUSE_HSREGEX -DUSE_EXPAT -I../lib/expat-lite
  -DNO_DL_NEEDED  -I/usr/local/apache/include -g -O2 -Wall -D_GNU_SOURCE
  -DHAVE_MEMMEM=1 -DSTDC_HEADERS=1 -DHAVE_LIMITS_H=1 -DHAVE_UNISTD_H=1
  -c mod_aecgi.c
  -o mod_aecgi.so mod_aecgi.o
apxs:Break: Command failed with rc=16711680
</pre>
Basically, something has gone wrong with your Apache installation (I haven't 
figured out why it happens yet).  The fix is to edit the following
lines in the <tt>apxs</tt> script:
<pre>
my $CFG_LD_SHLIB      = q();        
my $CFG_LDFLAGS_SHLIB = q(); 
</pre>
For the first line, insert <tt>gcc</tt> between the parentheses, and for the 
second line, insert <tt>-shared</tt> between the parentheses.  This edit
complete, rerun <tt>make</tt>.

If you get any other error, contact Drew Csillag.
</section>

</chapter>
<chapter id="configuration">
<title>Configuring AED, Apache, and Others</title>

<section id="overview">
<title>Overview of AED</title>

<p/>AED (the Application Environment Daemon) is a software tool that
serves web applications on behalf of a Web (HTTP) server. Its job is similar
to that of ASP, ColdFusion, or Vignette StoryServer. AED, however, has an architecture
that is different from these other application servers.

<p/>AED is not a "plug-in" or extension of a Web server; instead, it is its own
server, which lives behind a Web server and handles requests on behalf of the Web server.
AED cannot serve Web requests directly; it requires the Apache web server to do all
of the work of receiving Web (HTTP) requests and sending back the responses to the
clients making the requests.

<p/>The best way to describe the AED software architecture is to follow what happens
to a single Web (HTTP) request as it is handled by the Web server (Apache) and the AED
server:

<ol>

<li>
The client connects to the Apache web server and makes an HTTP request. 
Apache receives the request and prepares to "handle it"; that is, it begins to 
determine how it will send back a response to the request.
</li>

<li>Apache goes through several "request handling phases" which handle different
parts of the response. When configured for use with AED, Apache will do nothing
for most of these request handling phases. When Apache reaches the "main request
handling phase", it uses a extension module from the Skunk software to handle the request.
This extension module is called <tt>mod_aecgi</tt>. "AECGI" is a term that means 
that the request will be passed back to AED, and that all the needed information
about the request will be passed to AED in the same general way that Apache would
pass request information to CGI programs.
</li>

<li>
The <tt>mod_aecgi</tt> module then "handles the request". The first thing it does
is to take all of the environment variables available, including the variables
set by Apache to include request information. (For instance, the environment
variable <tt>REMOTE_ADDR</tt> will contain the IP address of the client making
the request. There are many other environment variables that contain request information,
and <tt>mod_aecgi</tt> gathers them all together.
</li>

<li>
<tt>mod_aecgi</tt> then encodes all of the environment variables into a special format
that the AED server will understand.
</li>

<li>
<tt>mod_aecgi</tt> then opens a connection to the AED server. The Apache configuration
will tell <tt>mod_aecgi</tt> on which host and on which port number the AED server is running.
The typical configuration has the AED listening on the unix socket
<tt>/tmp/aedsock</tt>.
</li>

<li>
 If the connection succeeds, <tt>mod_aecgi</tt> then sends the encoded
 environment variables over the connection, and waits for AED to
 return a response that can be sent back to the Web client. If the
 connection fails, <tt>mod_aecgi</tt> will retry the connection a few
 times (utilizing the socket addresses listed in the
 <tt>AECGIFailoverHosts</tt> configuration variable). If the retries
 also fail, <tt>mod_aecgi</tt> will return a 
 customizable "error page", with a 500 Server Error status, as the
 response to the client. 
</li>

<li>
AED, like Apache version 1, runs as a pool of processes. The AED "parent process" does not
listen for connections from <tt>mod_aecgi</tt>; its only job is to create "child processes"
that will do all the listening and request handling. (The amount of child processes it creates,
as well as other important things, are configurable in AED's configuration files.) Thus
when we say that "AED is running", we mean that the AED parent process is running and has
created one or more child processes that are listening for connections from <tt>mod_aecgi</tt>.
</li>

<li>
An AED child process, then, accepts the connection from <tt>mod_aecgi</tt> and receives
the encoded environment variables containing all of the request information. It then
decodes the variables and checks that they are OK.
</li>

<li>
AED then builds two "objects", a <tt>REQUEST</tt> and a <tt>RESPONSE</tt>. It fills the REQUEST
objects with request information from the environment variables, including an entire copy
of the environment variables. The RESPONSE object provides data and operations for the
subsequent web application to create a well-formed HTTP response to be sent back to the client.
</li>

<li>
AED then does request "pre-processing". Depending on its configuration, AED can run one or
more customized functions to do common things with the request, such as authentication, 
rewriting of URLs, and other modifications of information in the REQUEST object.
</li>

<li>
AED then looks at the URI of the document requested by the client, for example <tt>/index.html</tt>.
AED tries to find this document in its <tt>WebRoot</tt>, that is, its document filesystem. If
AED cannot find the document, it generates a customizable 404 Not Found response, returns it
to <tt>mod_aecgi</tt>, and closes the connection.
</li>

<li>
If AED does find the requested document, AED then looks at the "MIME type" of the document
to determine if the document is "static", and should be sent as-is with no modification. 
If the document is static, AED reads the contents of the document file, makes an HTTP
response out of it, and sends it back to <tt>mod_aecgi</tt>.
</li>

<li>
If the requested document is not static, it is considered "dynamic", which means that
the document contains programming code that should be executed to generate the HTTP response.
There are two kinds of dynamic programming languages supported: the Python programming
language, and a tag-based programming language called STML, or Skunk Template Markup Language.
As a rule, files ending in <tt>.py</tt> can contain Python code, and files ending in
<tt>.html</tt>, <tt>.txt</tt>, and other common text formats can contain STML tag code.
</li>

<li>
AED then runs the dynamic documents contents through a "compiler", which will turn the document
and its programmming instructions into executable code. The resulting code is executable
Python code; AED is written in the Python language. AED keeps a cache of compiled Python code
for each dynamic document so that it does not have to compile the same documents repeatedly.
</li>

<li>
Now that AED has executable code for the dynamic document, it sets up a special "execution
environment" for the code. It includes the REQUEST and RESPONSE objects, helpful utility
functions and modules, and special objects that monitor the executable code and capture the
response output that the code generates. AED then executes the code.
</li>

<li>
Dynamic documents often make use of a powerful feature in AED: they can use other special
dynamic documents to help generate the needed output. These special documents are called
<i>components</i>: they cannot be requested by <tt>mod_aecgi</tt>, but they can be used
as "building blocks" by dynamic documents and assembled together on the fly. Components
can be programmed in straight Python or as text with STML tag code embedded in the text.
Components also can accept "arguments" from the dynmiac documents, just as a function
can receive arguments from the code that calls the function.</li>

<li>
AED keeps track of all the components that a dynamic document tries to use. If an error
occurs in any code, or if a component is asked for by a dynamic document but does not 
exist, AED will "catch" the error, generate a customizable error page, and return
a 500 Server Error response to <tt>mod_aecgi</tt>.
</li>

<li>
AED also offers a powerful feature for components: <i>caching of component output</i>.
Components may indicate in their program code whether their output should be cached
by AED, and for how long. When a component whose output is cached is called, AED
does not even bother executing the component's code; AED simply retrieves the component's
output from the cache and proceeds. The component output cache is one of AED's
most important features, and it also has the most impact of server administration 
and performance.</li>

<li>
Once all of the dynamic document's code has executed (as well as all of the components
the document used) and no errors have occurred, AED gathers all of the response output
generated by the document's code, puts it in the RESPONSE object, and prepares to
send the response back to <tt>mod_aecgi</tt>.
</li>

<li>
AED examines the RESPONSE object, extracting the needed information and creating
a well-formed HTTP response, with headers and everything. AED then sends the HTTP
response over the connection to <tt>mod_aecgi</tt>, and then closes the connection.
</li>

<li>
<tt>mod_aecgi</tt> receives the HTTP response, tells Apache about the response, 
and finishes its job.
</li>

<li>
Apache, which now has the response generated by AED, performs any post-processing
on the response that it feels is necessary, and returns the response to the
client that requested it.
</li>

</ol>

</section>

<section id="aedconfig">
<title>Configuring AED</title>
Edit <tt>/usr/local/skunk/aed/etc/aed.conf</tt> and change the line
that sets the <tt>Personalities</tt> variable to enable the sql and
superteam personalities like this:
<pre>
Personalities = ['templating', 'sql', 'superteam']
</pre>
To use the <tt>helix</tt> personality instead, change
<tt>'superteam'</tt> to <tt>'helix'</tt>. 

If you want to change the locations of either the <tt>WebRoot</tt>
variable (where templates/components/datacomponents/etc. are stored
you can edit the <tt>/usr/<wbr/>local/skunk/aed/etc/templating.conf</tt>
file.

You can also change the location of the cache directory by altering
the <tt>CacheRoot</tt> variable in the same file.  If you do, make
sure to change the crontab entry for the cache reaper to use that
directory instead of <tt>/usr/local/skunk/<wbr/>webcache</tt>.


For database connectivity, the sql personality will need to be
configured properly.  To do this, you need to change some variables in
the <tt>/usr/local/skunk/<wbr/>aed/etc/sql.conf</tt> file.  Contacting
somebody on the team for whom is using this is probably the best way
to get these set to the correct values.  The variables in question will be
the <tt>DatabaseConnectStrings</tt> variable, which associates simple
names to database connect strings, and the
<tt>ProcedurePackageLists</tt> variable which is a means of preloading
descriptions of stored procedures used by the application.
</section>

<section id="apacheconfig">
<title>Configuring Apache to Work With Skunk</title>
Now that Skunk is installed, we'd like to able to get Apache talking
to it.

In the build directory <tt>AED/mod_aecgi/</tt> there is a file
<tt>httpd_conf.stub</tt> that you edit as necessary and paste on the
bottom of Apache's <tt>httpd.conf</tt> file.  

Apache also should be set to run as the user and group you specified during
the skunk configuration by changing the <tt>User</tt> and
<tt>Group</tt> configuration file options as necessary.

If you are using virtual
hosts with Apache, you would make the following change from:
<pre>
&lt;Location /&gt; 
    SetHandler aecgi-handler
&lt;/Location&gt;
</pre>

To:

<pre>
<i>common AECGI* configuration stuff</i>
&lt;VirtualHost <i>virtualhostspec</i>&gt;
<i>other virtual host configuration stuff</i>
&lt;Location /&gt; 
    SetHandler aecgi-handler
&lt;/Location&gt;
<i>any other AECGI* configuration specific to this virtual host</i>
&lt;/VirtualHost&gt;
</pre>


</section>

<section id="conffiles">
<title>Configuration Files</title>

<h3>HTTP Configuration in <tt>httpd.conf</tt> for <tt>mod_aecgi</tt></h3>

<dl>
<!--
<dt><tt>AECGIPort</tt></dt><dd>Port to which an AED should be listening to
</dd><dt><tt>AECGIHost</tt></dt><dd>Host to which an AED should be listening 
-->
<dt><tt>AECGISocketAddress</tt></dt><dd>The socket address of where an
AED is listening for requests.  For a TCP socket the format is host:port.  For a unix domain socket, the format is /path/to/socket
</dd><dt><tt>AECGIRetries</tt></dt><dd>Number of times to retry connecting to AED before showing them the error page
</dd><dt><tt>AECGIErrorDoc</tt></dt><dd>Path to error document to show when we can't talk to AED
</dd><dt><tt>AECGIErrorEmails</tt></dt><dd>Email addresses to send mail to when we fail
</dd><dt><tt>AECGIExclude</tt></dt><dd>space delimited list of uri prefixes that <tt>mod_aecgi</tt> should <b>NOT</b> handle.  If not specified, is empty list.
</dd><dt><tt>AECGIFailoverHosts</tt></dt><dd>space delimited list of
host:port and/or /path/to/socket combinations for which
<tt>mod_aecgi</tt> will try 
(picking randomly) to connect to in the event that it cannot connect
to <tt>AECGISocketAddress</tt>.  If not set, it will continue to
attempt to connect to <tt>AECGISocketAddress</tt>. 
</dd><dt><tt>AECGIConnectTimeout</tt></dt><dd>Number of milliseconds
that <tt>mod_aecgi</tt> will wait for the <tt>connect()</tt> call to
succeed before calling it a failure and retrying.  Default is one
second. 
</dd>
</dl>

<h2>AED configuration files</h2>

<h3><tt>aed.conf</tt></h3>
<dl>
<dt><tt>NumKids</tt></dt><dd>Number of AED children to spawn.  
8*# of CPUs is a good starting point, but see <xref id="perftuning"/>.  Default is 8.
</dd><dt><tt>PidFile</tt></dt><dd>location to put the process
id file.  If you change this from the default
(<tt>/usr/local/skunk/var/aed.pid</tt>), make sure to change the
<tt>aedmgr</tt> script's <tt>PIDFILE</tt> variable.
</dd><dt><tt>ListenQueue</tt></dt><dd>Length of the backlog queue on
the AED port. Default is 5.  This normally shouldn't need to be changed.
</dd><dt><tt>MaxSessions</tt></dt><dd>Number of requests an AED child
will serve before exiting (a new one will be respawned in its
place).  Default is 256.

<!--
</dd><dt><tt>BindHost localhost</tt></dt><dd>Host the AED will bind
to.  For security reasons this should normally be <tt>localhost</tt>
(which is the default), but for remote component usage, this may need
to be changed (and is safe if the app servers are behind the firewall
with cache servers in front), but see <xref id="security"/> for details.
</dd><dt><tt>BindPort</tt></dt><dd>TCP Port that AED should bind to.
Default is 9888
-->
</dd><dt><tt>BindAddresses</tt></dt><dd>The addresses where AED should listen for requests.  It is a 
      tuple of (address, <i>enable_remote_components</i>) where the address
      is either a string for a unix domain socket (specifying the path
      to it) or a tuple of (host, port) for a TCP socket.  If
      enable_remote_components is true, remote component calls will be
      enabled on this interface if <tt>EnableRemoteComponents</tt> is
      turned on.  Default is <tt>((('localhost', 9888), 1), ('/tmp/aedsock', 1))</tt> 
</dd><dt><tt>EnableRemoteComponents</tt></dt><dd>Enable this server to
serve remote component calls.  Default is 1 (for yes).
</dd><dt><tt>ServerName</tt></dt><dd>Name of
this server.  The default is the value returned by the gethostname
system call.
</dd><dt><tt>RemoteCacheTTL</tt></dt><dd>The amount of time that
remote components will be cached <b>irrespective</b> of whether or not
it was called <tt>cache=yes</tt>.  The default is 0.
</dd><dt><tt>SyslogFacility</tt></dt><dd>The syslog facility to do
it's copius syslog logging to.  Default is <tt>'local0'</tt>
</dd><dt><tt>Personalities</tt></dt><dd>List of
personalities that the AED should load.  Default is <tt>['templating']</tt>
</dd><dt><tt>Debug</tt></dt><dd>Include extra debug information in the
debug log file.  Default is <tt>no</tt>
</dd><dt><tt>LogFile logs/aed.log</tt></dt><dd>The location of the
main AED log file.  Default is <tt>/usr/local/skunk/logs/aed.log</tt>.
</dd><dt><tt>DebugLogFile logs/aed.debug</tt></dt><dd>Location of the
debug log file.  Default is <tt>/usr/local/skunk/logs/aed.debug</tt>.
</dd><dt><tt>ErrorLogFile logs/aed.error</tt></dt>Location of the
error log file.  Default is <tt>/usr/local/skunk/logs/aed.error</tt>.
</dl>

<h3><tt>templating.conf</tt></h3>
<dl>
<dt><tt>WebRoot</tt></dt><dd>Analogous to Apache's
<tt>DocumentRoot</tt> configuration directive.
</dd><dt><tt>CacheRoot</tt></dt><dd>Where the cache directory lives.
If this is changed, make sure to change the crontab entry for the
<tt>cache_reaper</tt>.
</dd><dt><tt>ComponentCacheRoot</tt></dt><dd>Where to put the cached
output of components.  If this value is different than
<tt>CacheRoot</tt>, make sure to change the crontab entry for the
<tt>cache_reaper</tt>.
</dd><dt><tt>CompCacheNumServers</tt></dt><dd>If using a shared
filesystem for the component cache (in a production farm, you should),
the number of shared filesystem servers you are using.  See the <xref
id='sharedcache'>Shared Caching</xref> section for more details.
</dd><dt><tt>CompCacheFailoverRoot</tt></dt><dd>A local filesystem
area to be used for component caching in the event that one of the
shared filesystem servers is down.
</dd><dt><tt>CompCacheFailoverRetry</tt></dt><dd>The number of seconds
to use the local component cache before attempting to use the shared
filesystem again after a failure.
</dd><dt><tt>ImageTTL</tt></dt><dd>Set the Expiration: HTTP header
this far in the future for images.  Default is 1 hour.
</dd><dt><tt>TemplateTTL</tt></dt><dd>If a component is called with
<tt>cache=1</tt> and the component doesn't set the cache expiration
(via either setting <tt>__expiration</tt> or use of a
<tt>&lt;:cache:&gt;</tt> tag, how long to cache for, in seconds.
Default is one year. 
</dd><dt><tt>DocumentTimeout</tt></dt><dd>The maximum amount of
time a request can take (otherwise the request is terminated and the
error page sent), in seconds.  Default is six minutes.
</dd><dt><tt>MimeTypesFile</tt></dt><dd>The location of the
extension->mime type mapping file.  Default location is
<tt>/usr/local/skunk/aed/personalities/templating/mime.types</tt>
</dd><dt><tt>TemplateMimetypes</tt></dt><dd>Mime types
that the AED considers as templates.  Default value is <tt>  (
'text/html', 'text/css', 'application/x-javascript', 'text/plain'
)</tt>
</dd><dt><tt>TemplateDebug</tt></dt><dd>If an error occurs during
the processing of a request, do we show the debugging information?
Default is <tt>no</tt>.  If <tt>no</tt> and an error occurs in
processing, the error page is shown.
</dd><dt><tt>TracebackDebug</tt></dt><dd>If <tt>TemplateDebug</tt>
is <tt>yes</tt> how much detail to show in the traceback.  The default
<tt>0</tt> just shows the traceback.  The value of <tt>1</tt> will
include a dump of the local and global variables that are either
integers, floats, strings or None.  If <tt>2</tt>, it will dump all
variables regardless of type.
</dd><dt><tt>UseCompileCache</tt></dt><dd>Whether or not to cache
compiled templates.  Default is <tt>yes</tt>.
</dd><dt><tt>UseTemplateCache</tt></dt><dd>Whether to honor the
<tt>cache=yes</tt> argument in component calls and cache the output to
disk.  Default is <tt>yes</tt>.
</dd><dt><tt>FallbackToCache</tt></dt><dd>Whether on error, to
fallback to a previously cached version.  Default is <tt>no</tt>.
This option <b>must</b> be turned on for deferred execution to work.
</dd><dt><tt>UseCompileMemCache</tt></dt><dd>Whether to cache
compiled templates in memory.  Default is <tt>no</tt>.
</dd><dt><tt>UseTemplateMemCache no</tt></dt><dd>Whether to cache the output
of cached components in memory.  Default is <tt>no</tt>.
</dd><dt><tt>AccessLog</tt></dt><dd>Location of the
access log file.  Default is <tt>/usr/local/skunk/logs/access.log</tt>.
</dd><dt><tt>HttpLog</tt></dt><dd>Location of the http
transaction log.  Default is <tt>/usr/local/skunk/logs/http.log</tt>.
</dd><dt><tt>UserLog</tt></dt><dd>Location of the user
log (messages generated by the application running on top of skunk).
Default is <tt>/usr/local/skunk/logs/user.log</tt>.
</dd><dt><tt>ImportPath</tt></dt><dd>Path to add to
<tt>sys.path</tt> after server start.  Default is
<tt>/usr/local/skunk/site-libs</tt>.
</dd><dt><tt>UserModuleCleanup</tt></dt><dd>Whether to clear out
Python modules loaded during a request should be cleared out after the
request finishes.  Default is <tt>no</tt>.
</dd><dt><tt>ErrorPage</tt></dt><dd>Location of a template to
be used (relative to <tt>WebRoot</tt>) to show when a request
encounters an error.
</dd><dt><tt>NotFoundPage</tt></dt><dd>Location of a template to
be used (relative to <tt>WebRoot</tt>) to show when a request comes in
for a document that doesn't exist.
</dd><dt><tt>MailHost </tt></dt><dd>Location of an SMTP
server that is to be used if the <tt>&lt;:sendmail:&gt;</tt> tag is used.
Default is <tt>'localhost'</tt>.
</dd><dt><tt>FromAddress</tt></dt><dd>Default from
address to send mail from if not specified in the
<tt>&lt;:sendmail:&gt;</tt> tag.  Default is the
<i>username</i>@<tt>ServerName</tt> where <i>username</i> is the name
of the user that the AED runs as.
</dd><dt><tt>DeferByDefault</tt></dt><dd>Use deferred mode for all
components unless they specify otherwise.  Default is <tt>no</tt>
</dd><dt><tt>MaxDeferredStale</tt></dt><dd>Maximum amount of
time past a components expiration time that we will use the cached
output of an expired
component in deferred mode, specified in seconds.  Default is 24 hours.
</dd><dt><tt>DefaultLanguage</tt></dt><dd>Default language to use
if not overridden by some means.  Default is <tt>'eng'</tt>.
</dd><dt><tt>StrictMessageCatalogs</tt></dt><dd>If set to <tt>yes</tt>, an
attempt to access a non-existant entry in a message catalog will fail
with an error, otherwise (set to <tt>no</tt>) a message returned
indicating that the requested message didn't exist.  Default is <tt>no</tt>.
</dd>
</dl>

<h3><tt>sql.conf</tt></h3>
<dl>
<dt><tt>DatabaseConnectStrings</tt></dt><dd>A dictionary of simple
name to Oracle connect strings.  Default is the empty dictionary (<tt>{}</tt>).
</dd><dt><tt>ProcedurePackageLists</tt></dt><dd>A dictionary of
simple username/list of stored procedure package names to be used to
pre-fetch descriptions of stored procedure argument and return types.
The default is the empty dictionary (<tt>{}</tt>). 
</dd>
</dl>

<h3><tt>superteam.conf</tt></h3>
Consult the gatos team as to what these really correspond to and
whether or not to change them, and if so, what to.  I've not a clue.
<dl> 
<dt><tt>UrlMappingFile</tt></dt><dd>
</dd><dt><tt>UrlAPIConfig</tt></dt><dd>
</dd><dt><tt>MastheadURL</tt></dt><dd>
</dd><dt><tt>LanguageAutoVar</tt></dt><dd>
</dd><dt><tt>BrandAutoVar</tt></dt><dd>
</dd><dt><tt>RegionAutoVar</tt></dt><dd>
</dd><dt><tt>DefaultBrand</tt></dt><dd>
</dd></dl>


</section>
<section id="ostuff">
<title>Setting up the Cache Reaper</title>
Add the following line to the crontab of the user that AED runs as
(all of it should be on one line):
<pre>
0 0 * * *  /usr/local/skunk/bin/cache_reaper.py 
          -c /usr/local/skunk/webcache
</pre>to clean up dead cache entries once per day (or you can adjust this to 
taste).  You may want to wrap the <tt>cache_reaper.py</tt> script with a shell
script to <tt>nice</tt> the process to make it run at a lower priority.
</section>

<section id="starting">
<title>Starting It All Up</title>
Now to test everthing to see that it all works.  First, we'll start
the AED.  Assuming that it was installed into
<tt>/usr/local/skunk</tt>, you'd do:
<pre>
# /usr/local/skunk/bin/aedmgr start
</pre>
If it spews any errors whose source isn't obvious, consult the
<tt>aed.error</tt> log file, and if you still can't figure it out, 
contact Drew Csillag.

Now to start Apache, which if installed in <tt>/usr/local/apache</tt>
as per the default, you'd do:
<pre>
# /usr/local/apache/bin/apachectl start
</pre>
Likewise, if it spews any errors whose source isn't obvious, contact Drew
Csillag.

You should now be able to fire up the browser pointing to the machine
and you should get a picture of a skunk (with a semi-random background
color -- try reloading a few times) and a congratulations message!
</section>

</chapter>

<chapter id="administration">
<title>Administration</title>

<section id="startstop">
<title>(Re)Starting and Stopping AED</title>

As we saw before in the installtion chapter, AED can be started by
typing:
<pre>
# /usr/local/skunk/bin/aedmgr start
</pre>

It can also be stopped by typing:
<pre>
# /usr/local/skunk/bin/aedmgr stop
</pre>

It can be gracefully restarted by typing:
<pre>
# /usr/local/skunk/bin/aedmgr restart
</pre>

The way that AED is stopped is by sending <tt>SIGTERM</tt> (signal 15)
to the AED parent process, which subsequently sends <tt>SIGTERM</tt>
to its children.  While children are handling requests, they block
<tt>SIGTERM</tt> until the request completes, so if a <tt>SIGTERM</tt>
signal was sent to them during the request, it is delivered to them
then.  The reason for this is so that they have a chance to finish a
request so that end users don't get an error message until it actually
shuts down.  The parent process, if the children haven't died off
after 5 seconds, sends <tt>SIGKILL</tt> (signal 9) to the children to
really kill them off.  The AED parent process then exits.

Restart is similar to stoppage except for the fact that the parent
process doesn't exit, it start spawning children again.  It is a
graceful restart in the fact that end-users should never see the error
generated from the Apache server when it can't connect, connections
will backlog when the children start dying off until they start up
again.

<h2>Why Would You Do Any of This?</h2>
Well, some of it is obvious, e.g. you start AED because you want it's
services, or you're shutting down the machine, both no-brainers.  

As for other reasons, you would restart AED if you made a configuration
change, if you rolled the logfiles (see <xref id="logfiles"/>) or if
you have the <tt>UserModuleCleanup</tt> templating personality
configuration variable set to <tt>no</tt> and a change to a module in the
<tt>site-libs</tt> directory was made.
</section>

<section id="logfiles">
<title>Log Files and Log Rolling</title>
There are normally six active logfiles in
<tt>/usr/local/skunk/logs</tt> and they are:
<dl>
<dt><tt>access.log</tt></dt><dd>a log of accesses to individual
components that says whether or not they were rendered or cached and
the rendering time.  For cached items, the rendering time is the time
it took to fetch it off the disk and it also displays the cached items
time to live.
</dd><dt><tt>aed.debug</tt></dt><dd>Basically the same as the contents
of <tt>aed.log</tt> unless the <tt>Debug</tt> option in
<tt>aed.conf</tt> has been turned on.  If you don't want the debug
log, you can change the <tt>DebugLogFile</tt> variable in
<tt>aed.conf</tt> to point to <tt>/dev/null</tt> instead.
</dd><dt><tt>aed.error</tt></dt><dd>Any error tracebacks generated by
the application, as well as signals caught by the child processes
(including things like <tt>SIGTERM</tt>).
</dd><dt><tt>aed.log</tt></dt><dd>Logs server and child process
start/stop events and clearcache messages.
</dd><dt><tt>http.log</tt></dt><dd>output very similar to Apache's
<tt>access_log</tt>.
</dd><dt><tt>user.log</tt></dt><dd>log messages generated by
applications running on top of AED
</dd>
</dl>

An example is probably the best way to explain how to roll the AED
logfiles.
<pre>
# pwd
/usr/local/skunk/logs
<i>move other generations of logfiles</i>
# mv access.log access.log.1
# mv aed.debug aed.debug.1
# mv aed.error aed.error.1
# mv aed.log aed.log.1
# mv http.log http.log.1
# mv user.log user.log.1
# /usr/local/skunk/bin/aedmgr restart
</pre>
</section>

</chapter>


<chapter id="perftuning">
<title>Performance Tuning</title>
As with any complex server, there are a lot of tradeoffs in tuning the
AED.  Most of them are of the speed vs. memory and speed vs. disk space
varieties.  In general, you want as much CPU power as you can get,
either by many little machines or by fewer, larger machines.

The following sections are organized by the AED configuration file
and configuration directive.

<section id="aedconftuning">
<title><tt>aed.conf</tt></title>

<dl>
<dt><tt>NumKids</tt></dt><dd>Should be appoximately 8*CPU as mentioned
before, but if you notice that the site is slow and your load average
is below 2*CPU, you may want to increase this value.  Conversely, if
your load average is higher than, say 3*CPU, lowering this value may
help (or may be a sign that you need more CPU horsepower).
</dd><dt><tt>ListenQueue</tt></dt><dd>This normally need not be changed,
but if you are getting connection refused messages from Apache,
bumping this up <i>may</i> help some since it increases the number of
connections that will backlog on a socket before the TCP layer will
start saying "connection refused".  Note that some operating systems
will somewhat honor this, in that the number that they will actually
backlog may be less.
</dd><dt><tt>MaxSessions</tt></dt><dd>256 is a good number, but if you notice
that there are an excessive amount of re-connects to Oracle,
increasing this should help some, but beware, normally, the AED's
memory consumption does grow slowly over time (depending on the
caching parameters in <tt>templating.conf</tt>), so there may be a
practical limit on how big this should really get.
</dd></dl>
</section>

<section id="templatingconftuning">
<title><tt>templating.conf</tt></title>

<dl>
<dt><tt>CacheRoot</tt></dt><dd>The filesystem in which this lives should be
a fast disk, mounted in either async mode or should be on a logging
filesystem due to the nature of the activity that the AED produces.
Specifically, the AED makes heavy use of the <tt>rename()</tt> system
call which 
alters filesystem metadata, so if you happen to scan the
<tt>access.log</tt> file in the AED log directory and happen to notice
that writes of cached components are taking around 60-70 milliseconds,
this is generally a hint that you probably need to take action to
speed things up.
</dd><dt><tt>CompCacheRoot</tt></dt><dd>If you wish to segment the
component output cache to be shared among machines, this is the path
where the component output should be placed.
</dd><dt><tt>CompCacheNumServers</tt></dt><dd>This should be set to
the number of shared remote filesystems you are using.  What will
happen is that AED takes the last 16 bits of the MD5 hash that is
computed for the hash key and takes the remainder of dividing that
value by <tt>CompCacheNumServers</tt> and uses the number as a path
component after <tt>CompCacheRoot</tt> and the normal component output
cache path.  For example, if <tt>CompCacheNumServers</tt> is 3,
<tt>CompCacheRoot</tt> is <tt>/usr/local/skunk/compcache</tt> and the
output file was
<tt>cachetarget.comp<wbr/>/7B<wbr/>/1F<wbr/>/7B1F15E01273CB5FB34EE0C6E81B95D5<wbr/>.cache</tt>,
it would be written to
<tt>/usr<wbr/>/local<wbr/>/skunk<wbr/>/compcache<wbr/>/2<wbr/>/cachetarget.comp<wbr/>/7B<wbr/>/1F<wbr/>/7B1F15E01273CB5FB34EE0C6E81B95D5<wbr/>.cache</tt>
(notice the <tt>/2/</tt>).  So in this case, you would have your 3
fileservers mounted on
<tt>/usr<wbr/>/local<wbr/>/skunk<wbr/>/compcache<wbr/>/0</tt>,
<tt>/usr<wbr/>/local<wbr/>/skunk<wbr/>/compcache<wbr/>/1</tt>
and 
<tt>/usr<wbr/>/local<wbr/>/skunk<wbr/>/compcache<wbr/>/2</tt>.
See <xref id='sharedcache'>Shared Caching</xref> for more information.
</dd><dt><tt>CompCacheFailoverRoot</tt></dt><dd>In the event that
writing or reading from one of the component cache directories fails,
the (presumably) local directory to use as a substitute until the
fileserver comes back up.

</dd><dt><tt>CompCacheFailoverRetry</tt></dt><dd>The number of seconds
to use the failover directory before trying the fileserver again.

</dd><dt><tt>UseTemplateMemCache</tt></dt><dd>Unless you have <i>a lot</i>
of memory (>4GB), <i>and</i> the number of cached versions of
templates are small, 
you don't want to use this option since, in addition to writing the
cached components to disk, it will also cache them in memory, per AED
process.  Basically, for SMN, just say no.
</dd><dt><tt>UseCompileMemCache</tt></dt><dd>This, on the other hand, while
still consuming memory, doesn't consume quite as much, since we are
only caching the compiled form of the templates, which, the compiled
templates in cache are small, and the number of them is <i>exactly</i>
bounded by the number of templates/components/etc. under the
<tt>WebRoot</tt>.  So in general, it is a good thing to say <tt>yes</tt>.
</dd><dt><tt>UserModuleCleanup</tt></dt><dd>What this does is make it so
that when templates and/or user code import Python modules, that they
do not get cleaned up after a request.  This incurs no additional
memory overhead (they have to be loaded anyway), but saves CPU since
they don't have to be repeatedly reloaded for every request which uses
them.  It may potentially cause problems if the modules have global
structures which grow over time, in which case memory utilization will
increase, but if that has been determined to be the case, beating on
the developer of the module developer should suffice to fix that,
since <tt>UserModuleCleanup</tt> is turned <tt>on</tt> on the
development servers.  For production servers, this option should be
turned off.
</dd><dt><tt>UseTemplateCache</tt></dt><dd>You <i>want</i> this turned on.  It
allows the AED to cache component output to disk.
</dd><dt><tt>UseCompileCache</tt></dt><dd>Again, you <i>want</i> this
turned on.  It allows the AED to cache compiled templates to disk, so
they don't have to incur the CPU and time cost of recompiling them for
each request (some templates can take >100ms to compile, compare with
the loading of the compiled form which takes around 2-4ms, depending
on size).
</dd><dt><tt>DeferByDefault</tt></dt><dd>For this option, you probably want to
talk to the application developers using the server, since depending
on what they want, using deferred template evaluation (described
below) by default may not be desirable, but if they do, makes it so
that the end user can get a faster response.

Deferred execution of a component means that if they call a cached
component and it has expired, but isn't too stale (as defined by the
<tt>MaxDeferredStale</tt> configuration variable), show the cached
form anyway, and evaluate the component after the response has been
sent.
</dd></dl>
</section>

<section id="sqlconftuning">
<title><tt>sql.conf</tt></title>

The <tt>sql.conf</tt> tuning options are luckily simple.  There is
only one configuration variable to tune,
<tt>ProcedurePackageLists</tt>.  If the application running on AED
uses stored procedures, it should set this so that the descriptions of
the arguments and return values of stored procedures gets loaded once:
at server start.  If not set, for every stored procedure call, a
<tt>DESCRIBE PROCEDURE</tt> request gets sent to Oracle.  So make sure
this is setup properly!
</section>
</chapter>

<chapter id="cachingarch">
<title>Caching Architecture</title>
The caching architecture of AED is fundamentally rather simple from
the OS's point of view and luckily doesn't get that much more
complicated when you get to the upper level details.  

For component output caching, which makes up the majority of the
number of files in the cache directory, we take the output of the
component and a hex string representation of the MD5 hash of the
component arguments and write it to a temp file.  We then rename it to
the real file name.  This is done so we don't have to worry about
write atomicity and having the AED load a half-written file, not to
mention that this scheme works properly over NFS!

An example:  say we have a component whose path is
<tt>/foo/bar/baz.comp</tt> and the argument hash is
<tt>0123456789ABCDEFFEDCBA9876543210</tt>.  The temp file will be
written into a file named
<tt>/foo/bar/baz.comp/01/23/<i>hostname</i><tt>_</tt><i>pid</i>.<i><wbr/>countervalue</i>.tmp</tt>
and subsequently renamed (when writing is complete) to 
<tt>/foo/bar/baz.comp/<wbr/>01/23/0123456789ABCDEFFEDCBA9876543210.cache</tt>.
There is another file written for component output with the same name
as the cache file, but replacing <tt>.cache</tt> with <tt>.key</tt>
which contains a somewhat textual form of the component arguments.

For compiled templates and compiled python code, there is no hash (and
thus, no <tt>.key</tt> file), so
the cache filename is
<i>path_to</i><tt>/</tt><i>templatename</i><tt>c</tt> and the rest of
the process is the same.

<section id='sharedcache'>
<title>Shared Component Cache Issues</title>

Often, it is very desirable to share the component cache across
application servers for performance, managability and synchronicity
issues.  Recent versions of the AED now support this better than
previous releases.  In previous releases, the compile cache and
component cache resided in the same directories, there was no
convienient way to split the <tt>CacheRoot</tt> among multiple
fileservers (except by a rather baroque method of symlinking selected
portions of the <tt>CacheRoot</tt> to different fileservers), and no
graceful way to handle fileserver failures.  Recent versions of AED
fix these issues.

The location of the component cache is now a separate configuration
variable (the <tt>ComponentCacheRoot</tt> configuration variable in
<tt>templating.conf</tt>).  The component cache can be segmented
easily among multiple fileservers and the AED will now fail over to a
local cache if the file server goes away unexpectedly. 

The component cache segmentation is done as follows.  If the
<tt>CompCacheNumServers</tt> configuration variable is set to
something other than 0, a number of options are now effective.  At the
top of the component cache root (CCR), there will be <i>N</i>
directories, where <i>N</i> is the number of servers, numbered
<i>0..N-1</i>.  You can either mount your remote volumes there or have
symbolic links to where they are actually mounted.  

When the AED goes to operate on a cached form of component output, it takes
the last 16 bits of the MD5 hash that it computed, mods it by the
number of fileservers and operates on the cache entry under the directory
numbered by the result of the mod operation.  If an operation fails
when operating on the component cache (other than the usual errors of
files existing already or files not existing), the AED will fail over
that servers portion of the component cache to the (presumably) local failover
cache (specified by the <tt>CompCacheFailoverRoot</tt> configuration
variable) for <tt>CompCacheFailoverRetry</tt> seconds.  After
<tt>CompCacheFailoverRetry</tt> seconds, it will again attempt to go
back to using that servers' directory under the CCR.

<b>NOTE:</b>The <tt>CompCacheFailoverRoot</tt> and
<tt>CompCacheFailoverRetry</tt> options are ineffective if
<tt>CompCacheNumServers</tt> is 0.

</section>
</chapter>

<chapter id="security">
<title>Security Issues</title>
AED's general stance is that we let the template developer do whatever
they want, but make it sufficiently inconvienient to do direct access
on local files.  To clarify: we don't prevent them from opening
arbitrary files that the user that AED runs as has access to, but in
practice, this practice isn't really needed, so it's not generally
done. 

Basically, the files we make it easy to access are files under the
<tt>WebRoot</tt>, in that all of the template tags deal with files
under to it (and the component renderer cannot escape from it, as
we check (do .. expansion and path trimming and the like)).

To access files outside of the <tt>WebRoot</tt> the application would
have to call <tt>open</tt> on a file.  But since in SM applications,
the only place you can put stuff where other machines can see it is
the database, local file access is rarely, if ever, used (I don't
think <i>any</i> applications do this).

As for <tt>BindAddresses</tt>, if the app servers are behind a firewall,
and fronted with, say, squid servers, binding to <tt>localhost</tt> is
not strictly necessary and you could specify <tt>''</tt> (the empty
string) which says to bind to all addresses on the machine, since
people from the outside cannot directly talk to AED except through
squid.

</chapter>

<chapter><title>Miscellaneous</title>
<section id="extramods"><title>Building Extra Modules</title>
If, in the course of running <tt>setup.py</tt>, it complains about missing
<tt>syslog</tt> or <tt>crypt</tt> modules, you need to build them
before you can continue.  In this section, we'll show you how.

First, make a temporary directory to do the build in.  Next, assuming
you installed Python into <tt>/usr/local/</tt>, there is a file in
<tt>/usr/local/lib/python1.5/config</tt> named
<tt>Makefile.pre.in</tt>.  Copy this file to your build directory.
Next, grab the <tt>cryptmodule.c</tt> and <tt>syslogmodule.c</tt>
files out of the Python build directory and copy them to your build
directory.

Next, we need to create a <tt>Setup</tt> file that contains the
following:
<codeblock>
*shared*
#-lcrypt may be needed if crypt isn't in libc
crypt cryptmodule.c
syslog syslogmodule.c
</codeblock>

Now that we have that out of the way, we now actually need to build
all of this.  First we need to make the <tt>Makefile</tt>.

<codeblock>
# make -f Makefile.pre.in boot
</codeblock>

Now that we have the <tt>Makefile</tt>, we simply type:
<codeblock>
# make
</codeblock>

Now copy the two <tt>.so</tt> files into
<tt>/usr/local/lib/python1.5/lib-dynload/</tt> and rerun
<tt>setup.py</tt>.

If it still fails on the <tt>crypt</tt> module, try uncommenting the
<tt>-lcrypt</tt> section of <tt>Setup</tt> and rebuild the
<tt>cryptmodule.so</tt>, and try running <tt>setup.py</tt> again.
</section>
</chapter>
