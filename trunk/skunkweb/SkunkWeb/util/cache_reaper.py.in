#!@PYTHON@
#  
#  Copyright (C) 2001 Andrew T. Csillag <drew_csillag@geocities.com>
#  
#      You may distribute under the terms of either the GNU General
#      Public License or the SkunkWeb License, as specified in the
#      README file.
#   
import sys

sys.path.append('@libdir@/pylibs')
import os
import cPickle
import time
import stat

import Config
from SkunkExcept import *

conf = Config.Config([
    Config.el('cachedir', 'cache directory', '@CACHE@',
              'c', 'cachedir', 'pathtocache'),
    Config.el('deadtime', 'how long after cache entry dies do we delete it',
              24 * 60 * 60, 'd', 'deadtime', 'seconds', convert_hook = int),
    Config.el('help', 'show this screen', None, 'h', 'help'),
    Config.el('preview', "don't actually delete, but show what would be done",
              None, 'p', 'preview'),
    ], 'walk the cache directory and reap dead entries')
    
def get_expiration(filename):
    try:
        metaDict = cPickle.load(open(filename))[0]
        return metaDict['exp_time']
    except:
        return None

# The number of cache entries reaped
_reaped, _total = 0, 0
def walk_func((dodel, deadtime), dirname, filelist):
    global _reaped, _total

    curtime=time.time()

    # Make a copy, since we mutate filelist
    full_list = filelist[:]

    for file in filelist:
	# Check the extension
	if file[-6:] != '.cache':
	    continue

        filename = os.path.join(dirname, file)

        _total = _total + 1

        exp_time = get_expiration(filename)

        if (exp_time is not None
            and exp_time < (curtime - deadtime)
            and exp_time != -1):
            #print 'Reaping %s\n    ttd=%d  tl=%d' % (filename, timestamp,
            #                                         curtime - deadtime)
            _reaped = _reaped + 1
            if dodel:
                keyfile = file[:-6] + '.key'

                for f in ( file, keyfile ):
                    # Wasteful
                    _f = os.path.join ( dirname, f )
                    try:
                        os.unlink( _f )
                    except OSError, val:
                        print >> sys.stderr, 'cannot unlink %s: %s' % \
                              ( _f, val )

                    # Get rid of the filename in the list, to prevent os.walk()
                    # from breaking
                    del filelist[filelist.index(f)]

try:
    args = conf.parse(sys.argv[1:])
except:
    conf.usage()
    sys.exit()
    
if conf['help'] or args:
    print conf.usage()
    sys.exit()

if conf['preview']:
    print 'running in preview mode'
    dodel = 0
else:
    dodel = 1

cacheDir = conf['cachedir']
deadtime = conf['deadtime']

print 'About to delete cache entries in %s expired more than %d ' \
      'seconds ago' % ( cacheDir, deadtime )

# Make a note of the time
_start_time = time.time()

os.path.walk(cacheDir, walk_func, (dodel, deadtime))

if dodel:
    sys.stdout.write ( 'Deleted ' )
else:
    sys.stdout.write ( 'Would have deleted ' )

print '%d out of %d total cache entries, time taken %.3f seconds' % \
      ( _reaped, _total, time.time() - _start_time )
