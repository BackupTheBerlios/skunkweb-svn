--------------------------------------------------
Requirements for formlib
--------------------------------------------------

> * fieldnames are of the form form.fieldname
> 
> * nothing we do should prohibit subforms, though we need not implement
>   support for them right away.
> * form field values will get placed into the state just after
>   fillDefaults
> 
> * the pageflow will be done in one of two ways depending on the user's
>   desires 
>   1) there is a formflow dict in the form set whose keys are the page
>      we start from, and the value is a command/argument (e.g. ('PUSH',
>      'formname)) or a function taking the arguments (cgiargs, state, <do
>      we need others?) which returns the command/argument.
>   2) Each form in the formset has a next() method which takes the same
>      arguments as the functions in formflow and serves the same purpose
>
> * As far as the AutoForm is concerned, the widget object is merely
>   something it can call view(defaultvalue, isinvalid) on to return the
>   html needed to display the widget and you pass all the other stuff
>   you want to appear in the tag via the constructor (more or less).

or after construction, by modifying attributes.
--------------------
may require adding a method to the Form stuff
--------------------

> * We supply some widget classes with formlib that work in the above
>   case as a convenience.

Just the form components, but all of them -- input, password,
textarea, select, etc.  Button groups are part of that.

> * The AutoForm's view method, by default, uses a named template to
>   render the form, which is supplied with formlib and will do some
>   basic stuff (e.g. put all of the widgets on the page), and is
>   configurable by some means, but you can tell the AutoForm to use
>   some other template instead, or could just hack the shit out of the
>   supplied template.

I don't know what you mean by template, but I did propose that the
default skin *not* be implemented with components, but with a library.
The default behavior should work right out of the box with a minimum
of configuration, and still be useful.  Skins should be possible to
construct which affect particular forms or the way that input widgets
are realized.  
----------------------------------------
> Ok.  I guess then we need to come up with the requirements of what you
> can do as far as customization with this library.

Let's not get hung up on exactly how skins would work until we have
some sort of prototype to react to; even if we decide to change the
way presentation is done, the main outlines of the service probably
won't be affected.
----------------------------------------

> * There is a state manager (which the viewer somewhere) which will
>   allow the form view() method to dump some html (likely hidden form
>   fields) into the page for state management.  It may do other things
>   such as fiddle with the session or cookies, but the initial
>   implementation will only have support for in-page state management.

> * We supply a single-submit library that formlib can use.
>   Alternatively, the single-submit code may be coupled to formlib

> * In which order should the validations take place in the case where
>   there is a subform on the page?  I'm thinking that main form
>   validation happens first, but is there a reason you can think of
>   that this would be a bad idea?  What then do we do with the results
>   of the subform's validate() return value? 
>   --not urgent since we've punted on subforms for now

I also don't know how much it matters what order you do the
validation.  If I submit a form and get five things wrong, I need to
be told about all five, normally, don't I?  

--------------------
True
--------------------

