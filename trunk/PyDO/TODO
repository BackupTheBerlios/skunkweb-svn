Summary:
  * refactor unique/sequenced and field declarations
  * introspection (especially, what are the columns of a table?)
  * connection caching and pooling
  * scatter fetch
  * docs
  * tests
  * first release

--

To catch up with the old PyDO:
  * scatterFetch (but am defering, see below)
  * more drivers
  * docs
  * connection caching

Other new features:
    - generating CREATE TABLE statements (not a huge priority of
      mine, but someone might use it). -- DEFER
    - joins could use additional parameters so you could add to the
      where clause. (?)


NOTES
-----

In the case of postgresql, it should usually be possible to determine
what sequence is being used by guessing, or by introspection.  In the
case of auto-increment, neither mysql nor sqlite needs a value
associated with the column id.  So we might be able to accept a
list/tuple rather than a dict for the combined auto_increment-
sequenced attribute.  Drivers would tell the PyDO class whether or
not to interpret the sequence as an auto_increment (get value after
insert) or sequence (get value before insert) kind of deal.

-- 

Any table without a unique constraint is immutable.  Any mutation of
an instance now checks _unique.

Fields still reserve second place for a database type, which is no
longer necessary.  I think going back to Jeroen's idea of putting
unique and sequence back in the fields declaration would be right.  I
didn't like the fact that there were two ways of declaring unique, but
that is how SQL works, also, and it would be convenient in many cases.
If I do this, perhaps "sequenced" should go away completely.  "unique"
must stay, because unique indexes can be multi-column.  

Let's find a way to specify fields in an easy way.

   fields=(Sequence('id', 'sequencename'),
           Unique('name'),
           'thing',
           'blah')

A sequence field
