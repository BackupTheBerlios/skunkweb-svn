

   
Skunk Software Operations Manual

   By Drew Csillag
   
   1: Introduction
   2: Installation
       2.1: Prerequisites
           2.1.1: Hardware and Operating System Prerequisites
           2.1.2: Software Prerequisites
           2.1.3: User and Group Prerequisites
       2.2: Fetching the Source Code
       2.3: Unpacking the Tarball
       2.4: Configuration and Build
   3: Configuring AED, Apache, and Others
       3.1: Overview of AED
       3.2: Configuring AED
       3.3: Configuring Apache to Work With Skunk
       3.4: Configuration Files
       3.5: Setting up the Cache Reaper
       3.6: Starting It All Up
   4: Administration
       4.1: (Re)Starting and Stopping AED
       4.2: Log Files and Log Rolling
   5: Performance Tuning
       5.1: aed.conf
       5.2: templating.conf
       5.3: sql.conf
   6: Caching Architecture
       6.1: Shared Component Cache Issues
   7: Security Issues
   8: Miscellaneous
       8.1: Building Extra Modules
     

   
Chapter: 1 -- Introduction

   This manual explains the installation and use of the software included
   in the Skunk software distribution.
   
   The Skunk software distribution has one main software tool: the AED
   web application server. AED stands for Application Environment Daemon,
   and AED's purpose is to provide a programming environment that makes
   it easy to build applications that generate "dynamic documents" in
   response to Web (HTTP) requests. Think of AED as doing the same job as
   Vignette StoryServer, ASP, ColdFusion, or regular CGI applications.
   
   The other software tools are utilities to help you use AED, or
   general-purpose software to help in web applications programming. This
   manual will concentrate almost exclusively on the use of AED, with
   little or no mention of the other software in the distribution.
     

   
Chapter: 2 -- Installation

   Section: 2.1 - Prerequisites
   Section: 2.2 - Fetching the Source Code
   Section: 2.3 - Unpacking the Tarball
   Section: 2.4 - Configuration and Build
     

   
Section: 2.1 -- Prerequisites

   Subsection: 2.1.1 - Hardware and Operating System Prerequisites
   Subsection: 2.1.2 - Software Prerequisites
   Subsection: 2.1.3 - User and Group Prerequisites
     

   
Subsection: 2.1.1 -- Hardware and Operating System Prerequisites

   The Skunk AED server, and all of the other software in the Skunk
   distribution, are designed to run on any Unix system. We have
   successfully built and installed Skunk software on Solaris 2.6 and
   2.7, various flavors of Linux 2.x, and recent versions of FreeBSD.
   
   There are no other hardware or operating system requirements.
     

   
Subsection: 2.1.2 -- Software Prerequisites

   The following software packages must be installed prior to installing
   the Skunk software.
   
     * GNU Make
     * GNU BASH
     * GNU Awk
     * gcc-2.95.2 (earlier versions are very likely ok)
     * GNU findutils-4.1
     * GNU fileutils-4.0
     * apache_1.3.12 configured with (at least) the switch
       --enable-module=so --disable-module=dir
       --disable-module=autoindex. Skunk will not build unless Apache has
       been configured for dynamic extension modules and will operate in
       occasionally very strange ways if the autoindex or dir modules are
       enabled.
     * Sudo
     * Python 1.5.2 compiled with the crypt and syslog modules installed.
       Much of the Skunk software is written in Python 1.5.2; the exact
       version of Python is very important.
     * Oracle client, precompiler, and some Oracle server files. The
       Skunk software includes a Python interface to Oracle called
       DCOracle. Since most of our web applications use Oracle databases,
       the DCOracle install is required. DCOracle, for some reason,
       requires not just the Oracle client libraries, but also the Oracle
       precompiler and some obscure files that can only be found in a
       full Oracle server installation. It is recommended that your
       machine have a full Oracle server installation to make DCOracle
       installation smooth and easy. If this is not possible, consult
       with Skunk software engineers to construct a custom Oracle
       installation that will support DCOracle.
       DCOracle is well-tested with Oracle 8.0.5 and 8.0.6 on Solaris and
       Linux. DCOracle has also been successfully built and used with
       Oracle 8.1.x on Linux.
     * PyXML, specifically for the helix persona (PyXML version 0.5.5.1
       is known to work).
     

   
Subsection: 2.1.3 -- User and Group Prerequisites

   It is recommended that the AED server run as the same user that the
   Apache server runs as. Historically, we have created a user named
   apache, with a home group named http, for both Apache and AED to run
   under. The Skunk software installation will create many directories
   and files owned by the user/group you choose during the installation;
   we recommend that you create the user apache and group http before
   starting the Skunk installation, so that the Skunk installer can use
   apache:http to set ownership of the files it installs.
     

   
Section: 2.2 -- Fetching the Source Code

   The source code is available from support.skunk.org. The links to the
   releases are at the bottom of the page. Skunk releases are named
   skunk-x.xx.tgz and are a gzipped tarball, where x.xx is the version
   number of the release. If you need the username and password to access
   the support website, contact either Drew Csillag or Robin Thomas.
     

   
Section: 2.3 -- Unpacking the Tarball

   To unpack the tarball under the current directory (a directory named
   skunk-2.xx will be created):
gzip -dc skunk-2.xx.tgz | tar xvf -
     

   
Section: 2.4 -- Configuration and Build

   First, log in as root. Then make sure that directory that you
   installed the GNU packages and Python into (via their --prefix
   argument, otherwise it's /usr/local) is in your PATH before
   /usr/ccs/bin (in fact, it's probably best if it were just first in
   your PATH). The bin directory of the apache install must also be in
   your path for configuration to succeed. If you did the default
   installs, you would add /usr/local/bin and /usr/local/apache/bin like
   this (for a bourne-like shell (bash, ksh, sh, etc.)):
# PATH=/usr/local/bin:$PATH:/usr/local/apache/bin
# export PATH

   Also, we need to make sure that the ORACLE_HOME environment variable
   points to the Oracle installation.
   
   You should get something like this:
# ls $ORACLE_HOME/bin/sqlplus
/opt/oracle/product/8.0.6/bin/sqlplus

   If you get something like this:
ls: /bin/sqlplus: No such file or directory

   Get your ORACLE_HOME environment variable set to the correct value
   before continuing. If in doubt, ask the local Oracle guru.
   
   Depending on how GNU Make was installed, there should be an executable
   named gmake in your path. If not, there needs to be.Assuming that GNU
   Make was installed in /usr/local/, make a link named gmake to make by
   doing the following:
# ln -s /usr/local/bin/make /usr/local/bin/gmake

   Now we need to cd to the skunk-2.xx directory created when we unpacked
   the tarball, and run the setup.py script like this:
   
# cd skunk-2.70
# python ./setup.py

   The setup script is now going to ask you a few questions.
   
Welcome to Skunk software installation
First we'll check a few things
checking for syslog module... Ok
checking for crypt module... Ok
Second, we need to ask a few questions
Do you wish to install AED? [Y/n]

   If it fails checking for either the syslog or crypt modules, see
   (Section: 8.1 - Building Extra Modules) on how to correct this. Since
   we do want to install AED, just press enter.
   
Do you wish to install DCOracle library -
NOTE: full Oracle 8 server installation required to build? [y/N]

   We do want to install the DCOracle library since it enables AED to
   talk to Oracle so type Y and press enter.
   
Enter default prefix for the installation? [/usr/local/skunk]

   If /usr/local/skunk is where you want to install it (more than likely,
   the answer here is "yes"), press enter, otherwise type the path to
   which skunk will be installed into.
   
Enter the username to install as? [drew]

   This probably should be changed as it should probably be apache. So
   type apache and press enter.
   
Enter the group to install as? [drew]

   This probably should be changed as it should probably be http. So type
   http and press enter.
   
   You may potentially get a message like the following:
WARNING: directory /usr/local/skunk/webroot exists. The installation usually
installs some sample documents there. If you did any
development in that directory, files could be lost.
If you would like to skip the the AED documents
installation, answer "y" (default) to the next question
Skip default content installation? [Y/n]

   Pressing enter here is more than likely what you want to do.
   
Please choose which personalities to install.
The templating personality is installed by default. You can
install a number of additional personalities, depending on what
you are planning to do with the server
Do you wish to install personality mysql? [y/N]

   Since we don't use MySQL in production, just press enter (for no).
   
Do you wish to install personality helix? [y/N]

   Since StarMedia applications use either the helix or the superteam
   personalities, say yes.
   
Do you wish to install personality postgresql? [y/N]

   Likewise for PostgreSQL, just press enter (for no).
   
Do you wish to install personality superteam? [y/N]

   This we do want to say yes to since it's used by StarMedia skunk-based
   applications. So press Y and hit enter.
   
Do you wish to install personality sql? [y/N]

   This is the personality which, in part, enables AED to access Oracle,
   so press Y and hit enter.
   
Do you wish to install personality skunkorg? [y/N]

   This is the personality used by the support.skunk.org website, so you
   don't need it, so just press enter (for no).
   
   You should then see something resembling the following:
This is what you have selected:
Installation directory: /usr/local/skunk
User to install as: apache.http
Install AED
--> Selected personalities: templating, superteam, sql
--> Install sample Web content
Install DCOracle oracle python interface
Are you sure you want to proceed? [Y/n]

   If everything looks ok, press enter to continue.
   
   You will then see a bunch of output that start with:
Running selected configure scripts...
===== Running top level config
loading cache ./config.cache
checking for gcc... (cached) gcc
checking whether the C compiler (gcc  ) works... yes
checking whether the C compiler (gcc

   If everything went ok, the last bits you should see on your screen are
   these:
creating AECore/aed.py
creating util/aedmgr
creating util/viewmeta.py
creating util/cache_reaper.py
All done! Now run gmake; gmake install to install Skunk

   If you see the following error, the configure script could not locate
   apxs, the apache extension building utility.
checking for apxs... notfound
configure: error: apxs not found! Make sure Apache is installed
AED config failed

   In this case check your PATH environment to see that it contains a
   directory which contains the apxs binary.
   
   There is a similar error which would occur if you did not configure
   Apache for dynamic module (sometimes referred to as DSO) support. If
   that is what the error said, reconfigure and rebuild apache with (at
   least) the switch --enable-module=so and retry configuring AED.
   
   If you see the following error:
checking for gmake... no
./configure: test: argument expected
Top level config failed

   This means that the gmake program could not be found. Likely, it is
   because you didn't do the check mentioned previously. Go back and make
   the symlink and try again.
   
   Now:
# gmake

   You should then see lines like this spew out:
Building component pylibs...
make[1]: Entering directory `/home/drew/build/skunk-2.70/pylibs'
(dirname=`echo signal_plus/Makefile.pre.in | sed 's@/Makefile.pre.in$@@'`; \
         make -C $dirname -f Makefile.pre.in boot)
make[2]: Entering directory `/home/drew/build/skunk-2.70/pylibs/signal_plus
'
rm -f *.o *~
rm -f *.a tags TAGS config.c Makefile.pre python sedscript
rm -f *.so *.sl so_locations
VERSION=`python -c "import sys; print sys.version[:3]"`; \
installdir=`python -c "import sys; print sys.prefix"`; \
exec_installdir=`python -c "import sys; print sys.exec_prefix"`; \
make -f ./Makefile.pre.in VPATH=. srcdir=. \
        VERSION=$VERSION \

Expected Warnings And Other Compiler/Linker Messages

   A whole bunch of these:
./mxDateTime.c: In function `mxDateTime_Getattr':
./mxDateTime.c:1876: warning: offset outside bounds of constant string

   Some others to be expected:
In file included from ./oci_.c:562:
Buffer.h:79: warning: static declaration for `PyImport_Import' follows
non-static
In file included from ./oci_.c:693:
oci_8.c: In function `Logon':
oci_8.c:154: warning: passing arg 4 of `OCIHandleAlloc' makes integer from
pointer without a cast
oci_8.c:189: warning: passing arg 1 of `OCIServerAttach' from incompatible
pointer type
oci_8.c: In function `newLob':
oci_8.c:561: warning: passing arg 4 of `OCIDescriptorAlloc' makes integer
from pointer without a cast
oci_8.c: In function `initoci_8':
oci_8.c:598: warning: passing arg 3 of `OCIEnvInit' makes integer from
pointer without a cast
./oci_.c: In function `_wrap_ogetpi':
./oci_.c:2879: warning: assignment from incompatible pointer type
./oci_.c:2882: warning: assignment from incompatible pointer type
gcc: -lclntsh: linker input file unused since linking not done
gcc: -lcore4: linker input file unused since linking not done
gcc: -lcommon: linker input file unused since linking not done
gcc: -lcore4: linker input file unused since linking not done
gcc: -lnlsrtl3: linker input file unused since linking not done

In file included from ./Buffer.c:60:
Buffer.h:79: warning: static declaration for `PyImport_Import'
follows non-static

   Anything other than these may be (probably isn't) a problem, so check
   with Drew Csillag. Of course, if you don't see these, that's ok too.
   
   Now it's time to install:
# gmake install

   If all goes well you should see something similar to the following:
Installing component pylibs...
gmake[1]: Entering directory `/home/drew/build/skunk-2.70/pylibs'
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
for f in Buffer.so oci_.so; do \
    /usr/bin/install -c -o apache -g http -m 644 -o apache -g http -D
./src/${f} /usr/local/skunk/pylibs/DCOracle/DCOracle/${f}; \
        done
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
for f in Buffer.so oci_.so; do \
    /usr/bin/install -c -o apache -g http -m 644 -o apache -g http -D
./src/${f} /usr/local/skunk/pylibs/DCOracle/DCOracle/${f}; \
        done
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/pylibs/DCOracle'
gmake[1]: Leaving directory `/home/drew/build/skunk-2.70/pylibs'
Installing component AED...
gmake[1]: Entering directory `/home/drew/build/skunk-2.70/AED'
Creating AED directory tree...
Installing component mod_aecgi...
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/AED/mod_aecgi'
/usr/local/apache/bin//apxs -i mod_aecgi.so
cp mod_aecgi.so /home/drew/programs/apache/libexec/mod_aecgi.so
chmod 755 /home/drew/programs/apache/libexec/mod_aecgi.so
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/AED/mod_aecgi'
Installing component personalities...
gmake[2]: Entering directory `/home/drew/build/skunk-2.70/AED/personalities'
Installing personality templating...
Installing personality superteam...
Installing personality sql...
gmake[2]: Leaving directory `/home/drew/build/skunk-2.70/AED/personalities'
Installing web content
gmake[1]: Leaving directory `/home/drew/build/skunk-2.70/AED'
#

   The following error has been seen when building on Linux machines:
make[2]: Entering directory
`/usr/local/downloads/skunk-2.73.beta4/AED/mod_aecgi'
   /usr/local/apache/bin/apxs -c -Wc,"-g -O2 -Wall -D_GNU_SOURCE
   -DHAVE_MEMMEM=1 -DSTDC_HEADERS=1 -DHAVE_LIMITS_H=1 -DHAVE_UNISTD_H=1 "
   -o mod_aecgi.so mod_aecgi.c
gcc -DLINUX=2 -DUSE_HSREGEX -DUSE_EXPAT -I../lib/expat-lite
  -DNO_DL_NEEDED  -I/usr/local/apache/include -g -O2 -Wall -D_GNU_SOURCE
  -DHAVE_MEMMEM=1 -DSTDC_HEADERS=1 -DHAVE_LIMITS_H=1 -DHAVE_UNISTD_H=1
  -c mod_aecgi.c
  -o mod_aecgi.so mod_aecgi.o
apxs:Break: Command failed with rc=16711680

   Basically, something has gone wrong with your Apache installation (I
   haven't figured out why it happens yet). The fix is to edit the
   following lines in the apxs script:
my $CFG_LD_SHLIB      = q();
my $CFG_LDFLAGS_SHLIB = q();

   For the first line, insert gcc between the parentheses, and for the
   second line, insert -shared between the parentheses. This edit
   complete, rerun make.
   
   If you get any other error, contact Drew Csillag.
     

   
Chapter: 3 -- Configuring AED, Apache, and Others

   Section: 3.1 - Overview of AED
   Section: 3.2 - Configuring AED
   Section: 3.3 - Configuring Apache to Work With Skunk
   Section: 3.4 - Configuration Files
   Section: 3.5 - Setting up the Cache Reaper
   Section: 3.6 - Starting It All Up
     

   
Section: 3.1 -- Overview of AED

   AED (the Application Environment Daemon) is a software tool that
   serves web applications on behalf of a Web (HTTP) server. Its job is
   similar to that of ASP, ColdFusion, or Vignette StoryServer. AED,
   however, has an architecture that is different from these other
   application servers.
   
   AED is not a "plug-in" or extension of a Web server; instead, it is
   its own server, which lives behind a Web server and handles requests
   on behalf of the Web server. AED cannot serve Web requests directly;
   it requires the Apache web server to do all of the work of receiving
   Web (HTTP) requests and sending back the responses to the clients
   making the requests.
   
   The best way to describe the AED software architecture is to follow
   what happens to a single Web (HTTP) request as it is handled by the
   Web server (Apache) and the AED server:
   
    1. The client connects to the Apache web server and makes an HTTP
       request. Apache receives the request and prepares to "handle it";
       that is, it begins to determine how it will send back a response
       to the request.
    2. Apache goes through several "request handling phases" which handle
       different parts of the response. When configured for use with AED,
       Apache will do nothing for most of these request handling phases.
       When Apache reaches the "main request handling phase", it uses a
       extension module from the Skunk software to handle the request.
       This extension module is called mod_aecgi. "AECGI" is a term that
       means that the request will be passed back to AED, and that all
       the needed information about the request will be passed to AED in
       the same general way that Apache would pass request information to
       CGI programs.
    3. The mod_aecgi module then "handles the request". The first thing
       it does is to take all of the environment variables available,
       including the variables set by Apache to include request
       information. (For instance, the environment variable REMOTE_ADDR
       will contain the IP address of the client making the request.
       There are many other environment variables that contain request
       information, and mod_aecgi gathers them all together.
    4. mod_aecgi then encodes all of the environment variables into a
       special format that the AED server will understand.
    5. mod_aecgi then opens a connection to the AED server. The Apache
       configuration will tell mod_aecgi on which host and on which port
       number the AED server is running. The typical configuration has
       the AED listening on the unix socket /tmp/aedsock.
    6. If the connection succeeds, mod_aecgi then sends the encoded
       environment variables over the connection, and waits for AED to
       return a response that can be sent back to the Web client. If the
       connection fails, mod_aecgi will retry the connection a few times
       (utilizing the socket addresses listed in the AECGIFailoverHosts
       configuration variable). If the retries also fail, mod_aecgi will
       return a customizable "error page", with a 500 Server Error
       status, as the response to the client.
    7. AED, like Apache version 1, runs as a pool of processes. The AED
       "parent process" does not listen for connections from mod_aecgi;
       its only job is to create "child processes" that will do all the
       listening and request handling. (The amount of child processes it
       creates, as well as other important things, are configurable in
       AED's configuration files.) Thus when we say that "AED is
       running", we mean that the AED parent process is running and has
       created one or more child processes that are listening for
       connections from mod_aecgi.
    8. An AED child process, then, accepts the connection from mod_aecgi
       and receives the encoded environment variables containing all of
       the request information. It then decodes the variables and checks
       that they are OK.
    9. AED then builds two "objects", a REQUEST and a RESPONSE. It fills
       the REQUEST objects with request information from the environment
       variables, including an entire copy of the environment variables.
       The RESPONSE object provides data and operations for the
       subsequent web application to create a well-formed HTTP response
       to be sent back to the client.
   10. AED then does request "pre-processing". Depending on its
       configuration, AED can run one or more customized functions to do
       common things with the request, such as authentication, rewriting
       of URLs, and other modifications of information in the REQUEST
       object.
   11. AED then looks at the URI of the document requested by the client,
       for example /index.html. AED tries to find this document in its
       WebRoot, that is, its document filesystem. If AED cannot find the
       document, it generates a customizable 404 Not Found response,
       returns it to mod_aecgi, and closes the connection.
   12. If AED does find the requested document, AED then looks at the
       "MIME type" of the document to determine if the document is
       "static", and should be sent as-is with no modification. If the
       document is static, AED reads the contents of the document file,
       makes an HTTP response out of it, and sends it back to mod_aecgi.
   13. If the requested document is not static, it is considered
       "dynamic", which means that the document contains programming code
       that should be executed to generate the HTTP response. There are
       two kinds of dynamic programming languages supported: the Python
       programming language, and a tag-based programming language called
       STML, or Skunk Template Markup Language. As a rule, files ending
       in .py can contain Python code, and files ending in .html, .txt,
       and other common text formats can contain STML tag code.
   14. AED then runs the dynamic documents contents through a "compiler",
       which will turn the document and its programmming instructions
       into executable code. The resulting code is executable Python
       code; AED is written in the Python language. AED keeps a cache of
       compiled Python code for each dynamic document so that it does not
       have to compile the same documents repeatedly.
   15. Now that AED has executable code for the dynamic document, it sets
       up a special "execution environment" for the code. It includes the
       REQUEST and RESPONSE objects, helpful utility functions and
       modules, and special objects that monitor the executable code and
       capture the response output that the code generates. AED then
       executes the code.
   16. Dynamic documents often make use of a powerful feature in AED:
       they can use other special dynamic documents to help generate the
       needed output. These special documents are called components: they
       cannot be requested by mod_aecgi, but they can be used as
       "building blocks" by dynamic documents and assembled together on
       the fly. Components can be programmed in straight Python or as
       text with STML tag code embedded in the text. Components also can
       accept "arguments" from the dynmiac documents, just as a function
       can receive arguments from the code that calls the function.
   17. AED keeps track of all the components that a dynamic document
       tries to use. If an error occurs in any code, or if a component is
       asked for by a dynamic document but does not exist, AED will
       "catch" the error, generate a customizable error page, and return
       a 500 Server Error response to mod_aecgi.
   18. AED also offers a powerful feature for components: caching of
       component output. Components may indicate in their program code
       whether their output should be cached by AED, and for how long.
       When a component whose output is cached is called, AED does not
       even bother executing the component's code; AED simply retrieves
       the component's output from the cache and proceeds. The component
       output cache is one of AED's most important features, and it also
       has the most impact of server administration and performance.
   19. Once all of the dynamic document's code has executed (as well as
       all of the components the document used) and no errors have
       occurred, AED gathers all of the response output generated by the
       document's code, puts it in the RESPONSE object, and prepares to
       send the response back to mod_aecgi.
   20. AED examines the RESPONSE object, extracting the needed
       information and creating a well-formed HTTP response, with headers
       and everything. AED then sends the HTTP response over the
       connection to mod_aecgi, and then closes the connection.
   21. mod_aecgi receives the HTTP response, tells Apache about the
       response, and finishes its job.
   22. Apache, which now has the response generated by AED, performs any
       post-processing on the response that it feels is necessary, and
       returns the response to the client that requested it.
     

   
Section: 3.2 -- Configuring AED

   Edit /usr/local/skunk/aed/etc/aed.conf and change the line that sets
   the Personalities variable to enable the sql and superteam
   personalities like this:
Personalities = ['templating', 'sql', 'superteam']

   To use the helix personality instead, change 'superteam' to 'helix'.
   
   If you want to change the locations of either the WebRoot variable
   (where templates/components/datacomponents/etc. are stored you can
   edit the /usr/local/skunk/aed/etc/templating.conf file.
   
   You can also change the location of the cache directory by altering
   the CacheRoot variable in the same file. If you do, make sure to
   change the crontab entry for the cache reaper to use that directory
   instead of /usr/local/skunk/webcache.
   
   For database connectivity, the sql personality will need to be
   configured properly. To do this, you need to change some variables in
   the /usr/local/skunk/aed/etc/sql.conf file. Contacting somebody on the
   team for whom is using this is probably the best way to get these set
   to the correct values. The variables in question will be the
   DatabaseConnectStrings variable, which associates simple names to
   database connect strings, and the ProcedurePackageLists variable which
   is a means of preloading descriptions of stored procedures used by the
   application.
     

   
Section: 3.3 -- Configuring Apache to Work With Skunk

   Now that Skunk is installed, we'd like to able to get Apache talking
   to it.
   
   In the build directory AED/mod_aecgi/ there is a file httpd_conf.stub
   that you edit as necessary and paste on the bottom of Apache's
   httpd.conf file.
   
   Apache also should be set to run as the user and group you specified
   during the skunk configuration by changing the User and Group
   configuration file options as necessary.
   
   If you are using virtual hosts with Apache, you would make the
   following change from:
<Location />
    SetHandler aecgi-handler
</Location>

   To:
   
common AECGI* configuration stuff
<VirtualHost virtualhostspec>
other virtual host configuration stuff
<Location />
    SetHandler aecgi-handler
</Location>
any other AECGI* configuration specific to this virtual host
</VirtualHost>
     

   
Section: 3.4 -- Configuration Files

  HTTP Configuration in httpd.conf for mod_aecgi
  
   AECGISocketAddress
          The socket address of where an AED is listening for requests.
          For a TCP socket the format is host:port. For a unix domain
          socket, the format is /path/to/socket
          
   AECGIRetries
          Number of times to retry connecting to AED before showing them
          the error page
          
   AECGIErrorDoc
          Path to error document to show when we can't talk to AED
          
   AECGIErrorEmails
          Email addresses to send mail to when we fail
          
   AECGIExclude
          space delimited list of uri prefixes that mod_aecgi should NOT
          handle. If not specified, is empty list.
          
   AECGIFailoverHosts
          space delimited list of host:port and/or /path/to/socket
          combinations for which mod_aecgi will try (picking randomly) to
          connect to in the event that it cannot connect to
          AECGISocketAddress. If not set, it will continue to attempt to
          connect to AECGISocketAddress.
          
   AECGIConnectTimeout
          Number of milliseconds that mod_aecgi will wait for the
          connect() call to succeed before calling it a failure and
          retrying. Default is one second.
          
AED configuration files

  aed.conf
  
   NumKids
          Number of AED children to spawn. 8*# of CPUs is a good starting
          point, but see (Chapter: 5 - Performance Tuning). Default is 8.
          
   PidFile
          location to put the process id file. If you change this from
          the default (/usr/local/skunk/var/aed.pid), make sure to change
          the aedmgr script's PIDFILE variable.
          
   ListenQueue
          Length of the backlog queue on the AED port. Default is 5. This
          normally shouldn't need to be changed.
          
   MaxSessions
          Number of requests an AED child will serve before exiting (a
          new one will be respawned in its place). Default is 256.
          
   BindAddresses
          The addresses where AED should listen for requests. It is a
          tuple of (address, enable_remote_components) where the address
          is either a string for a unix domain socket (specifying the
          path to it) or a tuple of (host, port) for a TCP socket. If
          enable_remote_components is true, remote component calls will
          be enabled on this interface if EnableRemoteComponents is
          turned on. Default is ((('localhost', 9888), 1),
          ('/tmp/aedsock', 1))
          
   EnableRemoteComponents
          Enable this server to serve remote component calls. Default is
          1 (for yes).
          
   ServerName
          Name of this server. The default is the value returned by the
          gethostname system call.
          
   RemoteCacheTTL
          The amount of time that remote components will be cached
          irrespective of whether or not it was called cache=yes. The
          default is 0.
          
   SyslogFacility
          The syslog facility to do it's copius syslog logging to.
          Default is 'local0'
          
   Personalities
          List of personalities that the AED should load. Default is
          ['templating']
          
   Debug
          Include extra debug information in the debug log file. Default
          is no
          
   LogFile logs/aed.log
          The location of the main AED log file. Default is
          /usr/local/skunk/logs/aed.log.
          
   DebugLogFile logs/aed.debug
          Location of the debug log file. Default is
          /usr/local/skunk/logs/aed.debug.
          
   ErrorLogFile logs/aed.errorLocation of the error log file. Default is
          /usr/local/skunk/logs/aed.error.
          
  templating.conf
  
   WebRoot
          Analogous to Apache's DocumentRoot configuration directive.
          
   CacheRoot
          Where the cache directory lives. If this is changed, make sure
          to change the crontab entry for the cache_reaper.
          
   ComponentCacheRoot
          Where to put the cached output of components. If this value is
          different than CacheRoot, make sure to change the crontab entry
          for the cache_reaper.
          
   CompCacheNumServers
          If using a shared filesystem for the component cache (in a
          production farm, you should), the number of shared filesystem
          servers you are using. See the Shared Caching (Section: 6.1 -
          Shared Component Cache Issues) section for more details.
          
   CompCacheFailoverRoot
          A local filesystem area to be used for component caching in the
          event that one of the shared filesystem servers is down.
          
   CompCacheFailoverRetry
          The number of seconds to use the local component cache before
          attempting to use the shared filesystem again after a failure.
          
   ImageTTL
          Set the Expiration: HTTP header this far in the future for
          images. Default is 1 hour.
          
   TemplateTTL
          If a component is called with cache=1 and the component doesn't
          set the cache expiration (via either setting __expiration or
          use of a <:cache:> tag, how long to cache for, in seconds.
          Default is one year.
          
   DocumentTimeout
          The maximum amount of time a request can take (otherwise the
          request is terminated and the error page sent), in seconds.
          Default is six minutes.
          
   MimeTypesFile
          The location of the extension->mime type mapping file. Default
          location is
          /usr/local/skunk/aed/personalities/templating/mime.types
          
   TemplateMimetypes
          Mime types that the AED considers as templates. Default value
          is ( 'text/html', 'text/css', 'application/x-javascript',
          'text/plain' )
          
   TemplateDebug
          If an error occurs during the processing of a request, do we
          show the debugging information? Default is no. If no and an
          error occurs in processing, the error page is shown.
          
   TracebackDebug
          If TemplateDebug is yes how much detail to show in the
          traceback. The default 0 just shows the traceback. The value of
          1 will include a dump of the local and global variables that
          are either integers, floats, strings or None. If 2, it will
          dump all variables regardless of type.
          
   UseCompileCache
          Whether or not to cache compiled templates. Default is yes.
          
   UseTemplateCache
          Whether to honor the cache=yes argument in component calls and
          cache the output to disk. Default is yes.
          
   FallbackToCache
          Whether on error, to fallback to a previously cached version.
          Default is no. This option must be turned on for deferred
          execution to work.
          
   UseCompileMemCache
          Whether to cache compiled templates in memory. Default is no.
          
   UseTemplateMemCache no
          Whether to cache the output of cached components in memory.
          Default is no.
          
   AccessLog
          Location of the access log file. Default is
          /usr/local/skunk/logs/access.log.
          
   HttpLog
          Location of the http transaction log. Default is
          /usr/local/skunk/logs/http.log.
          
   UserLog
          Location of the user log (messages generated by the application
          running on top of skunk). Default is
          /usr/local/skunk/logs/user.log.
          
   ImportPath
          Path to add to sys.path after server start. Default is
          /usr/local/skunk/site-libs.
          
   UserModuleCleanup
          Whether to clear out Python modules loaded during a request
          should be cleared out after the request finishes. Default is
          no.
          
   ErrorPage
          Location of a template to be used (relative to WebRoot) to show
          when a request encounters an error.
          
   NotFoundPage
          Location of a template to be used (relative to WebRoot) to show
          when a request comes in for a document that doesn't exist.
          
   MailHost
          Location of an SMTP server that is to be used if the
          <:sendmail:> tag is used. Default is 'localhost'.
          
   FromAddress
          Default from address to send mail from if not specified in the
          <:sendmail:> tag. Default is the username@ServerName where
          username is the name of the user that the AED runs as.
          
   DeferByDefault
          Use deferred mode for all components unless they specify
          otherwise. Default is no
          
   MaxDeferredStale
          Maximum amount of time past a components expiration time that
          we will use the cached output of an expired component in
          deferred mode, specified in seconds. Default is 24 hours.
          
   DefaultLanguage
          Default language to use if not overridden by some means.
          Default is 'eng'.
          
   StrictMessageCatalogs
          If set to yes, an attempt to access a non-existant entry in a
          message catalog will fail with an error, otherwise (set to no)
          a message returned indicating that the requested message didn't
          exist. Default is no.
          
  sql.conf
  
   DatabaseConnectStrings
          A dictionary of simple name to Oracle connect strings. Default
          is the empty dictionary ({}).
          
   ProcedurePackageLists
          A dictionary of simple username/list of stored procedure
          package names to be used to pre-fetch descriptions of stored
          procedure argument and return types. The default is the empty
          dictionary ({}).
          
  superteam.conf
  
   Consult the gatos team as to what these really correspond to and
   whether or not to change them, and if so, what to. I've not a clue.
   
   UrlMappingFile
          
   UrlAPIConfig
          
   MastheadURL
          
   LanguageAutoVar
          
   BrandAutoVar
          
   RegionAutoVar
          
   DefaultBrand
     

   
Section: 3.5 -- Setting up the Cache Reaper

   Add the following line to the crontab of the user that AED runs as
   (all of it should be on one line):
0 0 * * *  /usr/local/skunk/bin/cache_reaper.py
          -c /usr/local/skunk/webcache

   to clean up dead cache entries once per day (or you can adjust this to
   taste). You may want to wrap the cache_reaper.py script with a shell
   script to nice the process to make it run at a lower priority.
     

   
Section: 3.6 -- Starting It All Up

   Now to test everthing to see that it all works. First, we'll start the
   AED. Assuming that it was installed into /usr/local/skunk, you'd do:
# /usr/local/skunk/bin/aedmgr start

   If it spews any errors whose source isn't obvious, consult the
   aed.error log file, and if you still can't figure it out, contact Drew
   Csillag.
   
   Now to start Apache, which if installed in /usr/local/apache as per
   the default, you'd do:
# /usr/local/apache/bin/apachectl start

   Likewise, if it spews any errors whose source isn't obvious, contact
   Drew Csillag.
   
   You should now be able to fire up the browser pointing to the machine
   and you should get a picture of a skunk (with a semi-random background
   color -- try reloading a few times) and a congratulations message!
     

   
Chapter: 4 -- Administration

   Section: 4.1 - (Re)Starting and Stopping AED
   Section: 4.2 - Log Files and Log Rolling
     

   
Section: 4.1 -- (Re)Starting and Stopping AED

   As we saw before in the installtion chapter, AED can be started by
   typing:
# /usr/local/skunk/bin/aedmgr start

   It can also be stopped by typing:
# /usr/local/skunk/bin/aedmgr stop

   It can be gracefully restarted by typing:
# /usr/local/skunk/bin/aedmgr restart

   The way that AED is stopped is by sending SIGTERM (signal 15) to the
   AED parent process, which subsequently sends SIGTERM to its children.
   While children are handling requests, they block SIGTERM until the
   request completes, so if a SIGTERM signal was sent to them during the
   request, it is delivered to them then. The reason for this is so that
   they have a chance to finish a request so that end users don't get an
   error message until it actually shuts down. The parent process, if the
   children haven't died off after 5 seconds, sends SIGKILL (signal 9) to
   the children to really kill them off. The AED parent process then
   exits.
   
   Restart is similar to stoppage except for the fact that the parent
   process doesn't exit, it start spawning children again. It is a
   graceful restart in the fact that end-users should never see the error
   generated from the Apache server when it can't connect, connections
   will backlog when the children start dying off until they start up
   again.
   
Why Would You Do Any of This?

   Well, some of it is obvious, e.g. you start AED because you want it's
   services, or you're shutting down the machine, both no-brainers.
   
   As for other reasons, you would restart AED if you made a
   configuration change, if you rolled the logfiles (see (Section: 4.2 -
   Log Files and Log Rolling)) or if you have the UserModuleCleanup
   templating personality configuration variable set to no and a change
   to a module in the site-libs directory was made.
     

   
Section: 4.2 -- Log Files and Log Rolling

   There are normally six active logfiles in /usr/local/skunk/logs and
   they are:
   
   access.log
          a log of accesses to individual components that says whether or
          not they were rendered or cached and the rendering time. For
          cached items, the rendering time is the time it took to fetch
          it off the disk and it also displays the cached items time to
          live.
          
   aed.debug
          Basically the same as the contents of aed.log unless the Debug
          option in aed.conf has been turned on. If you don't want the
          debug log, you can change the DebugLogFile variable in aed.conf
          to point to /dev/null instead.
          
   aed.error
          Any error tracebacks generated by the application, as well as
          signals caught by the child processes (including things like
          SIGTERM).
          
   aed.log
          Logs server and child process start/stop events and clearcache
          messages.
          
   http.log
          output very similar to Apache's access_log.
          
   user.log
          log messages generated by applications running on top of AED
          
   An example is probably the best way to explain how to roll the AED
   logfiles.
# pwd
/usr/local/skunk/logs
move other generations of logfiles
# mv access.log access.log.1
# mv aed.debug aed.debug.1
# mv aed.error aed.error.1
# mv aed.log aed.log.1
# mv http.log http.log.1
# mv user.log user.log.1
# /usr/local/skunk/bin/aedmgr restart
     

   
Chapter: 5 -- Performance Tuning

   Section: 5.1 - aed.conf
   Section: 5.2 - templating.conf
   Section: 5.3 - sql.conf
   
   As with any complex server, there are a lot of tradeoffs in tuning the
   AED. Most of them are of the speed vs. memory and speed vs. disk space
   varieties. In general, you want as much CPU power as you can get,
   either by many little machines or by fewer, larger machines.
   
   The following sections are organized by the AED configuration file and
   configuration directive.
     

   
Section: 5.1 -- aed.conf

   NumKids
          Should be appoximately 8*CPU as mentioned before, but if you
          notice that the site is slow and your load average is below
          2*CPU, you may want to increase this value. Conversely, if your
          load average is higher than, say 3*CPU, lowering this value may
          help (or may be a sign that you need more CPU horsepower).
          
   ListenQueue
          This normally need not be changed, but if you are getting
          connection refused messages from Apache, bumping this up may
          help some since it increases the number of connections that
          will backlog on a socket before the TCP layer will start saying
          "connection refused". Note that some operating systems will
          somewhat honor this, in that the number that they will actually
          backlog may be less.
          
   MaxSessions
          256 is a good number, but if you notice that there are an
          excessive amount of re-connects to Oracle, increasing this
          should help some, but beware, normally, the AED's memory
          consumption does grow slowly over time (depending on the
          caching parameters in templating.conf), so there may be a
          practical limit on how big this should really get.
     

   
Section: 5.2 -- templating.conf

   CacheRoot
          The filesystem in which this lives should be a fast disk,
          mounted in either async mode or should be on a logging
          filesystem due to the nature of the activity that the AED
          produces. Specifically, the AED makes heavy use of the rename()
          system call which alters filesystem metadata, so if you happen
          to scan the access.log file in the AED log directory and happen
          to notice that writes of cached components are taking around
          60-70 milliseconds, this is generally a hint that you probably
          need to take action to speed things up.
          
   CompCacheRoot
          If you wish to segment the component output cache to be shared
          among machines, this is the path where the component output
          should be placed.
          
   CompCacheNumServers
          This should be set to the number of shared remote filesystems
          you are using. What will happen is that AED takes the last 16
          bits of the MD5 hash that is computed for the hash key and
          takes the remainder of dividing that value by
          CompCacheNumServers and uses the number as a path component
          after CompCacheRoot and the normal component output cache path.
          For example, if CompCacheNumServers is 3, CompCacheRoot is
          /usr/local/skunk/compcache and the output file was
          cachetarget.comp/7B/1F/7B1F15E01273CB5FB34EE0C6E81B95D5.cache,
          it would be written to /usr/local/skunk/compcache/2
          /cachetarget.comp/7B/1F/7B1F15E01273CB5FB34EE0C6E81B95D5.cache
          (notice the /2/). So in this case, you would have your 3
          fileservers mounted on /usr/local/skunk/compcache/0, /usr/local
          /skunk/compcache/1 and /usr/local/skunk/compcache/2. See Shared
          Caching (Section: 6.1 - Shared Component Cache Issues) for more
          information.
          
   CompCacheFailoverRoot
          In the event that writing or reading from one of the component
          cache directories fails, the (presumably) local directory to
          use as a substitute until the fileserver comes back up.
          
   CompCacheFailoverRetry
          The number of seconds to use the failover directory before
          trying the fileserver again.
          
   UseTemplateMemCache
          Unless you have a lot of memory (>4GB), and the number of
          cached versions of templates are small, you don't want to use
          this option since, in addition to writing the cached components
          to disk, it will also cache them in memory, per AED process.
          Basically, for SMN, just say no.
          
   UseCompileMemCache
          This, on the other hand, while still consuming memory, doesn't
          consume quite as much, since we are only caching the compiled
          form of the templates, which, the compiled templates in cache
          are small, and the number of them is exactly bounded by the
          number of templates/components/etc. under the WebRoot. So in
          general, it is a good thing to say yes.
          
   UserModuleCleanup
          What this does is make it so that when templates and/or user
          code import Python modules, that they do not get cleaned up
          after a request. This incurs no additional memory overhead
          (they have to be loaded anyway), but saves CPU since they don't
          have to be repeatedly reloaded for every request which uses
          them. It may potentially cause problems if the modules have
          global structures which grow over time, in which case memory
          utilization will increase, but if that has been determined to
          be the case, beating on the developer of the module developer
          should suffice to fix that, since UserModuleCleanup is turned
          on on the development servers. For production servers, this
          option should be turned off.
          
   UseTemplateCache
          You want this turned on. It allows the AED to cache component
          output to disk.
          
   UseCompileCache
          Again, you want this turned on. It allows the AED to cache
          compiled templates to disk, so they don't have to incur the CPU
          and time cost of recompiling them for each request (some
          templates can take >100ms to compile, compare with the loading
          of the compiled form which takes around 2-4ms, depending on
          size).
          
   DeferByDefault
          For this option, you probably want to talk to the application
          developers using the server, since depending on what they want,
          using deferred template evaluation (described below) by default
          may not be desirable, but if they do, makes it so that the end
          user can get a faster response.
          
          Deferred execution of a component means that if they call a
          cached component and it has expired, but isn't too stale (as
          defined by the MaxDeferredStale configuration variable), show
          the cached form anyway, and evaluate the component after the
          response has been sent.
     

   
Section: 5.3 -- sql.conf

   The sql.conf tuning options are luckily simple. There is only one
   configuration variable to tune, ProcedurePackageLists. If the
   application running on AED uses stored procedures, it should set this
   so that the descriptions of the arguments and return values of stored
   procedures gets loaded once: at server start. If not set, for every
   stored procedure call, a DESCRIBE PROCEDURE request gets sent to
   Oracle. So make sure this is setup properly!
     

   
Chapter: 6 -- Caching Architecture

   Section: 6.1 - Shared Component Cache Issues
   
   The caching architecture of AED is fundamentally rather simple from
   the OS's point of view and luckily doesn't get that much more
   complicated when you get to the upper level details.
   
   For component output caching, which makes up the majority of the
   number of files in the cache directory, we take the output of the
   component and a hex string representation of the MD5 hash of the
   component arguments and write it to a temp file. We then rename it to
   the real file name. This is done so we don't have to worry about write
   atomicity and having the AED load a half-written file, not to mention
   that this scheme works properly over NFS!
   
   An example: say we have a component whose path is /foo/bar/baz.comp
   and the argument hash is 0123456789ABCDEFFEDCBA9876543210. The temp
   file will be written into a file named
   /foo/bar/baz.comp/01/23/hostname_pid.countervalue.tmp and subsequently
   renamed (when writing is complete) to /foo/bar/baz.comp/
   01/23/0123456789ABCDEFFEDCBA9876543210.cache. There is another file
   written for component output with the same name as the cache file, but
   replacing .cache with .key which contains a somewhat textual form of
   the component arguments.
   
   For compiled templates and compiled python code, there is no hash (and
   thus, no .key file), so the cache filename is path_to/templatenamec
   and the rest of the process is the same.
     

   
Section: 6.1 -- Shared Component Cache Issues

   Often, it is very desirable to share the component cache across
   application servers for performance, managability and synchronicity
   issues. Recent versions of the AED now support this better than
   previous releases. In previous releases, the compile cache and
   component cache resided in the same directories, there was no
   convienient way to split the CacheRoot among multiple fileservers
   (except by a rather baroque method of symlinking selected portions of
   the CacheRoot to different fileservers), and no graceful way to handle
   fileserver failures. Recent versions of AED fix these issues.
   
   The location of the component cache is now a separate configuration
   variable (the ComponentCacheRoot configuration variable in
   templating.conf). The component cache can be segmented easily among
   multiple fileservers and the AED will now fail over to a local cache
   if the file server goes away unexpectedly.
   
   The component cache segmentation is done as follows. If the
   CompCacheNumServers configuration variable is set to something other
   than 0, a number of options are now effective. At the top of the
   component cache root (CCR), there will be N directories, where N is
   the number of servers, numbered 0..N-1. You can either mount your
   remote volumes there or have symbolic links to where they are actually
   mounted.
   
   When the AED goes to operate on a cached form of component output, it
   takes the last 16 bits of the MD5 hash that it computed, mods it by
   the number of fileservers and operates on the cache entry under the
   directory numbered by the result of the mod operation. If an operation
   fails when operating on the component cache (other than the usual
   errors of files existing already or files not existing), the AED will
   fail over that servers portion of the component cache to the
   (presumably) local failover cache (specified by the
   CompCacheFailoverRoot configuration variable) for
   CompCacheFailoverRetry seconds. After CompCacheFailoverRetry seconds,
   it will again attempt to go back to using that servers' directory
   under the CCR.
   
   NOTE:The CompCacheFailoverRoot and CompCacheFailoverRetry options are
   ineffective if CompCacheNumServers is 0.
     

   
Chapter: 7 -- Security Issues

   AED's general stance is that we let the template developer do whatever
   they want, but make it sufficiently inconvienient to do direct access
   on local files. To clarify: we don't prevent them from opening
   arbitrary files that the user that AED runs as has access to, but in
   practice, this practice isn't really needed, so it's not generally
   done.
   
   Basically, the files we make it easy to access are files under the
   WebRoot, in that all of the template tags deal with files under to it
   (and the component renderer cannot escape from it, as we check (do ..
   expansion and path trimming and the like)).
   
   To access files outside of the WebRoot the application would have to
   call open on a file. But since in SM applications, the only place you
   can put stuff where other machines can see it is the database, local
   file access is rarely, if ever, used (I don't think any applications
   do this).
   
   As for BindAddresses, if the app servers are behind a firewall, and
   fronted with, say, squid servers, binding to localhost is not strictly
   necessary and you could specify '' (the empty string) which says to
   bind to all addresses on the machine, since people from the outside
   cannot directly talk to AED except through squid.
     

   
Chapter: 8 -- Miscellaneous

   Section: 8.1 - Building Extra Modules
     

   
Section: 8.1 -- Building Extra Modules

   If, in the course of running setup.py, it complains about missing
   syslog or crypt modules, you need to build them before you can
   continue. In this section, we'll show you how.
   
   First, make a temporary directory to do the build in. Next, assuming
   you installed Python into /usr/local/, there is a file in
   /usr/local/lib/python1.5/config named Makefile.pre.in. Copy this file
   to your build directory. Next, grab the cryptmodule.c and
   syslogmodule.c files out of the Python build directory and copy them
   to your build directory.
   
   Next, we need to create a Setup file that contains the following:
*shared*
#-lcrypt may be needed if crypt isn't in libc
crypt cryptmodule.c
syslog syslogmodule.c

   Now that we have that out of the way, we now actually need to build
   all of this. First we need to make the Makefile.
   
# make -f Makefile.pre.in boot

   Now that we have the Makefile, we simply type:
# make

   Now copy the two .so files into /usr/local/lib/python1.5/lib-dynload/
   and rerun setup.py.
   
   If it still fails on the crypt module, try uncommenting the -lcrypt
   section of Setup and rebuild the cryptmodule.so, and try running
   setup.py again.
     
